// Package cdsenergy provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package cdsenergy

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for CommonPhysicalAddressAddressUType.
const (
	Paf    CommonPhysicalAddressAddressUType = "paf"
	Simple CommonPhysicalAddressAddressUType = "simple"
)

// Defines values for EnergyAccountBaseV2OpenStatus.
const (
	EnergyAccountBaseV2OpenStatusCLOSED EnergyAccountBaseV2OpenStatus = "CLOSED"
	EnergyAccountBaseV2OpenStatusOPEN   EnergyAccountBaseV2OpenStatus = "OPEN"
)

// Defines values for EnergyAccountDetailV2OpenStatus.
const (
	EnergyAccountDetailV2OpenStatusCLOSED EnergyAccountDetailV2OpenStatus = "CLOSED"
	EnergyAccountDetailV2OpenStatusOPEN   EnergyAccountDetailV2OpenStatus = "OPEN"
)

// Defines values for EnergyAccountDetailV2AllOfPlanDetailFuelType.
const (
	EnergyAccountDetailV2AllOfPlanDetailFuelTypeDUAL        EnergyAccountDetailV2AllOfPlanDetailFuelType = "DUAL"
	EnergyAccountDetailV2AllOfPlanDetailFuelTypeELECTRICITY EnergyAccountDetailV2AllOfPlanDetailFuelType = "ELECTRICITY"
	EnergyAccountDetailV2AllOfPlanDetailFuelTypeGAS         EnergyAccountDetailV2AllOfPlanDetailFuelType = "GAS"
)

// Defines values for EnergyAccountV2OpenStatus.
const (
	EnergyAccountV2OpenStatusCLOSED EnergyAccountV2OpenStatus = "CLOSED"
	EnergyAccountV2OpenStatusOPEN   EnergyAccountV2OpenStatus = "OPEN"
)

// Defines values for EnergyBillingDemandTransactionTimeOfUseType.
const (
	EnergyBillingDemandTransactionTimeOfUseTypeAGGREGATE           EnergyBillingDemandTransactionTimeOfUseType = "AGGREGATE"
	EnergyBillingDemandTransactionTimeOfUseTypeCONTROLLEDLOAD      EnergyBillingDemandTransactionTimeOfUseType = "CONTROLLED_LOAD"
	EnergyBillingDemandTransactionTimeOfUseTypeOFFPEAK             EnergyBillingDemandTransactionTimeOfUseType = "OFF_PEAK"
	EnergyBillingDemandTransactionTimeOfUseTypeOFFPEAKDEMANDCHARGE EnergyBillingDemandTransactionTimeOfUseType = "OFF_PEAK_DEMAND_CHARGE"
	EnergyBillingDemandTransactionTimeOfUseTypePEAK                EnergyBillingDemandTransactionTimeOfUseType = "PEAK"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER            EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER1           EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER1"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER2           EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER2"
	EnergyBillingDemandTransactionTimeOfUseTypeSOLAR               EnergyBillingDemandTransactionTimeOfUseType = "SOLAR"
)

// Defines values for EnergyBillingOtherTransactionType.
const (
	EnergyBillingOtherTransactionTypeENVIRONMENTAL EnergyBillingOtherTransactionType = "ENVIRONMENTAL"
	EnergyBillingOtherTransactionTypeMETERING      EnergyBillingOtherTransactionType = "METERING"
	EnergyBillingOtherTransactionTypeNETWORK       EnergyBillingOtherTransactionType = "NETWORK"
	EnergyBillingOtherTransactionTypeOTHER         EnergyBillingOtherTransactionType = "OTHER"
	EnergyBillingOtherTransactionTypeRCTI          EnergyBillingOtherTransactionType = "RCTI"
	EnergyBillingOtherTransactionTypeREGULATED     EnergyBillingOtherTransactionType = "REGULATED"
	EnergyBillingOtherTransactionTypeRETAILSERVICE EnergyBillingOtherTransactionType = "RETAIL_SERVICE"
)

// Defines values for EnergyBillingPaymentTransactionMethod.
const (
	EnergyBillingPaymentTransactionMethodBPAY        EnergyBillingPaymentTransactionMethod = "BPAY"
	EnergyBillingPaymentTransactionMethodCARD        EnergyBillingPaymentTransactionMethod = "CARD"
	EnergyBillingPaymentTransactionMethodCASH        EnergyBillingPaymentTransactionMethod = "CASH"
	EnergyBillingPaymentTransactionMethodCHEQUE      EnergyBillingPaymentTransactionMethod = "CHEQUE"
	EnergyBillingPaymentTransactionMethodDIRECTDEBIT EnergyBillingPaymentTransactionMethod = "DIRECT_DEBIT"
	EnergyBillingPaymentTransactionMethodOTHER       EnergyBillingPaymentTransactionMethod = "OTHER"
	EnergyBillingPaymentTransactionMethodTRANSFER    EnergyBillingPaymentTransactionMethod = "TRANSFER"
)

// Defines values for EnergyBillingTransactionTransactionUType.
const (
	Demand       EnergyBillingTransactionTransactionUType = "demand"
	OnceOff      EnergyBillingTransactionTransactionUType = "onceOff"
	OtherCharges EnergyBillingTransactionTransactionUType = "otherCharges"
	Payment      EnergyBillingTransactionTransactionUType = "payment"
	Usage        EnergyBillingTransactionTransactionUType = "usage"
)

// Defines values for EnergyBillingUsageTransactionMeasureUnit.
const (
	EnergyBillingUsageTransactionMeasureUnitDAYS  EnergyBillingUsageTransactionMeasureUnit = "DAYS"
	EnergyBillingUsageTransactionMeasureUnitKVA   EnergyBillingUsageTransactionMeasureUnit = "KVA"
	EnergyBillingUsageTransactionMeasureUnitKVAR  EnergyBillingUsageTransactionMeasureUnit = "KVAR"
	EnergyBillingUsageTransactionMeasureUnitKVARH EnergyBillingUsageTransactionMeasureUnit = "KVARH"
	EnergyBillingUsageTransactionMeasureUnitKW    EnergyBillingUsageTransactionMeasureUnit = "KW"
	EnergyBillingUsageTransactionMeasureUnitKWH   EnergyBillingUsageTransactionMeasureUnit = "KWH"
	EnergyBillingUsageTransactionMeasureUnitMETER EnergyBillingUsageTransactionMeasureUnit = "METER"
	EnergyBillingUsageTransactionMeasureUnitMONTH EnergyBillingUsageTransactionMeasureUnit = "MONTH"
)

// Defines values for EnergyBillingUsageTransactionTimeOfUseType.
const (
	EnergyBillingUsageTransactionTimeOfUseTypeAGGREGATE           EnergyBillingUsageTransactionTimeOfUseType = "AGGREGATE"
	EnergyBillingUsageTransactionTimeOfUseTypeCONTROLLEDLOAD      EnergyBillingUsageTransactionTimeOfUseType = "CONTROLLED_LOAD"
	EnergyBillingUsageTransactionTimeOfUseTypeOFFPEAK             EnergyBillingUsageTransactionTimeOfUseType = "OFF_PEAK"
	EnergyBillingUsageTransactionTimeOfUseTypeOFFPEAKDEMANDCHARGE EnergyBillingUsageTransactionTimeOfUseType = "OFF_PEAK_DEMAND_CHARGE"
	EnergyBillingUsageTransactionTimeOfUseTypePEAK                EnergyBillingUsageTransactionTimeOfUseType = "PEAK"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER            EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER1           EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER1"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER2           EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER2"
	EnergyBillingUsageTransactionTimeOfUseTypeSOLAR               EnergyBillingUsageTransactionTimeOfUseType = "SOLAR"
)

// Defines values for EnergyBillingUsageTransactionCalculationFactorsType.
const (
	DLF EnergyBillingUsageTransactionCalculationFactorsType = "DLF"
	MLF EnergyBillingUsageTransactionCalculationFactorsType = "MLF"
)

// Defines values for EnergyConcessionAppliedTo.
const (
	CONTROLLEDLOAD EnergyConcessionAppliedTo = "CONTROLLED_LOAD"
	INVOICE        EnergyConcessionAppliedTo = "INVOICE"
	SERVICECHARGE  EnergyConcessionAppliedTo = "SERVICE_CHARGE"
	USAGE          EnergyConcessionAppliedTo = "USAGE"
)

// Defines values for EnergyConcessionType.
const (
	EnergyConcessionTypeFIXEDAMOUNT     EnergyConcessionType = "FIXED_AMOUNT"
	EnergyConcessionTypeFIXEDPERCENTAGE EnergyConcessionType = "FIXED_PERCENTAGE"
	EnergyConcessionTypeVARIABLE        EnergyConcessionType = "VARIABLE"
)

// Defines values for EnergyDerRecordAcConnectionsEquipmentType.
const (
	EnergyDerRecordAcConnectionsEquipmentTypeINVERTER EnergyDerRecordAcConnectionsEquipmentType = "INVERTER"
	EnergyDerRecordAcConnectionsEquipmentTypeOTHER    EnergyDerRecordAcConnectionsEquipmentType = "OTHER"
)

// Defines values for EnergyDerRecordAcConnectionsStatus.
const (
	EnergyDerRecordAcConnectionsStatusACTIVE         EnergyDerRecordAcConnectionsStatus = "ACTIVE"
	EnergyDerRecordAcConnectionsStatusDECOMMISSIONED EnergyDerRecordAcConnectionsStatus = "DECOMMISSIONED"
	EnergyDerRecordAcConnectionsStatusINACTIVE       EnergyDerRecordAcConnectionsStatus = "INACTIVE"
)

// Defines values for EnergyDerRecordDerDevicesStatus.
const (
	EnergyDerRecordDerDevicesStatusACTIVE         EnergyDerRecordDerDevicesStatus = "ACTIVE"
	EnergyDerRecordDerDevicesStatusDECOMMISSIONED EnergyDerRecordDerDevicesStatus = "DECOMMISSIONED"
	EnergyDerRecordDerDevicesStatusINACTIVE       EnergyDerRecordDerDevicesStatus = "INACTIVE"
)

// Defines values for EnergyDerRecordDerDevicesType.
const (
	EnergyDerRecordDerDevicesTypeFOSSIL     EnergyDerRecordDerDevicesType = "FOSSIL"
	EnergyDerRecordDerDevicesTypeGEOTHERMAL EnergyDerRecordDerDevicesType = "GEOTHERMAL"
	EnergyDerRecordDerDevicesTypeHYDRO      EnergyDerRecordDerDevicesType = "HYDRO"
	EnergyDerRecordDerDevicesTypeOTHER      EnergyDerRecordDerDevicesType = "OTHER"
	EnergyDerRecordDerDevicesTypeRENEWABLE  EnergyDerRecordDerDevicesType = "RENEWABLE"
	EnergyDerRecordDerDevicesTypeSOLARPV    EnergyDerRecordDerDevicesType = "SOLAR_PV"
	EnergyDerRecordDerDevicesTypeSTORAGE    EnergyDerRecordDerDevicesType = "STORAGE"
	EnergyDerRecordDerDevicesTypeWIND       EnergyDerRecordDerDevicesType = "WIND"
)

// Defines values for EnergyInvoicePaymentStatus.
const (
	NOTPAID       EnergyInvoicePaymentStatus = "NOT_PAID"
	PAID          EnergyInvoicePaymentStatus = "PAID"
	PARTIALLYPAID EnergyInvoicePaymentStatus = "PARTIALLY_PAID"
)

// Defines values for EnergyInvoiceGasUsageChargesOtherChargesType.
const (
	EnergyInvoiceGasUsageChargesOtherChargesTypeENVIRONMENTAL EnergyInvoiceGasUsageChargesOtherChargesType = "ENVIRONMENTAL"
	EnergyInvoiceGasUsageChargesOtherChargesTypeMETERING      EnergyInvoiceGasUsageChargesOtherChargesType = "METERING"
	EnergyInvoiceGasUsageChargesOtherChargesTypeNETWORK       EnergyInvoiceGasUsageChargesOtherChargesType = "NETWORK"
	EnergyInvoiceGasUsageChargesOtherChargesTypeOTHER         EnergyInvoiceGasUsageChargesOtherChargesType = "OTHER"
	EnergyInvoiceGasUsageChargesOtherChargesTypeRCTI          EnergyInvoiceGasUsageChargesOtherChargesType = "RCTI"
	EnergyInvoiceGasUsageChargesOtherChargesTypeREGULATED     EnergyInvoiceGasUsageChargesOtherChargesType = "REGULATED"
	EnergyInvoiceGasUsageChargesOtherChargesTypeRETAILSERVICE EnergyInvoiceGasUsageChargesOtherChargesType = "RETAIL_SERVICE"
)

// Defines values for EnergyPaymentSchedulePaymentScheduleUType.
const (
	CardDebit     EnergyPaymentSchedulePaymentScheduleUType = "cardDebit"
	DigitalWallet EnergyPaymentSchedulePaymentScheduleUType = "digitalWallet"
	DirectDebit   EnergyPaymentSchedulePaymentScheduleUType = "directDebit"
	ManualPayment EnergyPaymentSchedulePaymentScheduleUType = "manualPayment"
)

// Defines values for EnergyPaymentScheduleCardDebitCalculationType.
const (
	EnergyPaymentScheduleCardDebitCalculationTypeBALANCE    EnergyPaymentScheduleCardDebitCalculationType = "BALANCE"
	EnergyPaymentScheduleCardDebitCalculationTypeCALCULATED EnergyPaymentScheduleCardDebitCalculationType = "CALCULATED"
	EnergyPaymentScheduleCardDebitCalculationTypeSTATIC     EnergyPaymentScheduleCardDebitCalculationType = "STATIC"
)

// Defines values for EnergyPaymentScheduleCardDebitCardScheme.
const (
	EnergyPaymentScheduleCardDebitCardSchemeAMEX       EnergyPaymentScheduleCardDebitCardScheme = "AMEX"
	EnergyPaymentScheduleCardDebitCardSchemeDINERS     EnergyPaymentScheduleCardDebitCardScheme = "DINERS"
	EnergyPaymentScheduleCardDebitCardSchemeMASTERCARD EnergyPaymentScheduleCardDebitCardScheme = "MASTERCARD"
	EnergyPaymentScheduleCardDebitCardSchemeOTHER      EnergyPaymentScheduleCardDebitCardScheme = "OTHER"
	EnergyPaymentScheduleCardDebitCardSchemeUNKNOWN    EnergyPaymentScheduleCardDebitCardScheme = "UNKNOWN"
	EnergyPaymentScheduleCardDebitCardSchemeVISA       EnergyPaymentScheduleCardDebitCardScheme = "VISA"
)

// Defines values for EnergyPaymentScheduleDigitalWalletCalculationType.
const (
	EnergyPaymentScheduleDigitalWalletCalculationTypeBALANCE    EnergyPaymentScheduleDigitalWalletCalculationType = "BALANCE"
	EnergyPaymentScheduleDigitalWalletCalculationTypeCALCULATED EnergyPaymentScheduleDigitalWalletCalculationType = "CALCULATED"
	EnergyPaymentScheduleDigitalWalletCalculationTypeSTATIC     EnergyPaymentScheduleDigitalWalletCalculationType = "STATIC"
)

// Defines values for EnergyPaymentScheduleDigitalWalletProvider.
const (
	EnergyPaymentScheduleDigitalWalletProviderOTHER    EnergyPaymentScheduleDigitalWalletProvider = "OTHER"
	EnergyPaymentScheduleDigitalWalletProviderPAYPALAU EnergyPaymentScheduleDigitalWalletProvider = "PAYPAL_AU"
)

// Defines values for EnergyPaymentScheduleDigitalWalletType.
const (
	CONTACTNAME EnergyPaymentScheduleDigitalWalletType = "CONTACT_NAME"
	EMAIL       EnergyPaymentScheduleDigitalWalletType = "EMAIL"
	TELEPHONE   EnergyPaymentScheduleDigitalWalletType = "TELEPHONE"
)

// Defines values for EnergyPaymentScheduleDirectDebitCalculationType.
const (
	BALANCE    EnergyPaymentScheduleDirectDebitCalculationType = "BALANCE"
	CALCULATED EnergyPaymentScheduleDirectDebitCalculationType = "CALCULATED"
	STATIC     EnergyPaymentScheduleDirectDebitCalculationType = "STATIC"
)

// Defines values for EnergyPlanCustomerType.
const (
	EnergyPlanCustomerTypeBUSINESS    EnergyPlanCustomerType = "BUSINESS"
	EnergyPlanCustomerTypeRESIDENTIAL EnergyPlanCustomerType = "RESIDENTIAL"
)

// Defines values for EnergyPlanFuelType.
const (
	EnergyPlanFuelTypeDUAL        EnergyPlanFuelType = "DUAL"
	EnergyPlanFuelTypeELECTRICITY EnergyPlanFuelType = "ELECTRICITY"
	EnergyPlanFuelTypeGAS         EnergyPlanFuelType = "GAS"
)

// Defines values for EnergyPlanType.
const (
	EnergyPlanTypeMARKET    EnergyPlanType = "MARKET"
	EnergyPlanTypeREGULATED EnergyPlanType = "REGULATED"
	EnergyPlanTypeSTANDING  EnergyPlanType = "STANDING"
)

// Defines values for EnergyPlanContractControlledLoadRateBlockUType.
const (
	EnergyPlanContractControlledLoadRateBlockUTypeSingleRate     EnergyPlanContractControlledLoadRateBlockUType = "singleRate"
	EnergyPlanContractControlledLoadRateBlockUTypeTimeOfUseRates EnergyPlanContractControlledLoadRateBlockUType = "timeOfUseRates"
)

// Defines values for EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit.
const (
	EnergyPlanContractControlledLoadSingleRateRatesMeasureUnitDAYS  EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit = "DAYS"
	EnergyPlanContractControlledLoadSingleRateRatesMeasureUnitKVA   EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit = "KVA"
	EnergyPlanContractControlledLoadSingleRateRatesMeasureUnitKVAR  EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit = "KVAR"
	EnergyPlanContractControlledLoadSingleRateRatesMeasureUnitKVARH EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit = "KVARH"
	EnergyPlanContractControlledLoadSingleRateRatesMeasureUnitKW    EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit = "KW"
	EnergyPlanContractControlledLoadSingleRateRatesMeasureUnitKWH   EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit = "KWH"
	EnergyPlanContractControlledLoadSingleRateRatesMeasureUnitMETER EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit = "METER"
	EnergyPlanContractControlledLoadSingleRateRatesMeasureUnitMONTH EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit.
const (
	EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnitDAYS  EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit = "DAYS"
	EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnitKVA   EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVA"
	EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnitKVAR  EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVAR"
	EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnitKVARH EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVARH"
	EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnitKW    EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit = "KW"
	EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnitKWH   EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit = "KWH"
	EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnitMETER EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit = "METER"
	EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnitMONTH EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays.
const (
	EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDaysFRI            EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays = "FRI"
	EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDaysMON            EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays = "MON"
	EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDaysPUBLICHOLIDAYS EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays = "PUBLIC_HOLIDAYS"
	EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDaysSAT            EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays = "SAT"
	EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDaysSUN            EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays = "SUN"
	EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDaysTHU            EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays = "THU"
	EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDaysTUE            EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays = "TUE"
	EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDaysWED            EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays = "WED"
)

// Defines values for EnergyPlanContractControlledLoadTimeOfUseRatesType.
const (
	EnergyPlanContractControlledLoadTimeOfUseRatesTypeOFFPEAK     EnergyPlanContractControlledLoadTimeOfUseRatesType = "OFF_PEAK"
	EnergyPlanContractControlledLoadTimeOfUseRatesTypePEAK        EnergyPlanContractControlledLoadTimeOfUseRatesType = "PEAK"
	EnergyPlanContractControlledLoadTimeOfUseRatesTypeSHOULDER    EnergyPlanContractControlledLoadTimeOfUseRatesType = "SHOULDER"
	EnergyPlanContractControlledLoadTimeOfUseRatesTypeSOLARSPONGE EnergyPlanContractControlledLoadTimeOfUseRatesType = "SOLAR_SPONGE"
)

// Defines values for EnergyPlanContractDiscountsCategory.
const (
	EnergyPlanContractDiscountsCategoryDIRECTDEBIT        EnergyPlanContractDiscountsCategory = "DIRECT_DEBIT"
	EnergyPlanContractDiscountsCategoryGUARANTEEDDISCOUNT EnergyPlanContractDiscountsCategory = "GUARANTEED_DISCOUNT"
	EnergyPlanContractDiscountsCategoryOTHER              EnergyPlanContractDiscountsCategory = "OTHER"
	EnergyPlanContractDiscountsCategoryPAYONTIME          EnergyPlanContractDiscountsCategory = "PAY_ON_TIME"
)

// Defines values for EnergyPlanContractDiscountsMethodUType.
const (
	EnergyPlanContractDiscountsMethodUTypeFixedAmount          EnergyPlanContractDiscountsMethodUType = "fixedAmount"
	EnergyPlanContractDiscountsMethodUTypePercentOfBill        EnergyPlanContractDiscountsMethodUType = "percentOfBill"
	EnergyPlanContractDiscountsMethodUTypePercentOfUse         EnergyPlanContractDiscountsMethodUType = "percentOfUse"
	EnergyPlanContractDiscountsMethodUTypePercentOverThreshold EnergyPlanContractDiscountsMethodUType = "percentOverThreshold"
)

// Defines values for EnergyPlanContractDiscountsType.
const (
	EnergyPlanContractDiscountsTypeCONDITIONAL EnergyPlanContractDiscountsType = "CONDITIONAL"
	EnergyPlanContractDiscountsTypeGUARANTEED  EnergyPlanContractDiscountsType = "GUARANTEED"
	EnergyPlanContractDiscountsTypeOTHER       EnergyPlanContractDiscountsType = "OTHER"
)

// Defines values for EnergyPlanContractEligibilityType.
const (
	EnergyPlanContractEligibilityTypeCONTINGENTPLAN     EnergyPlanContractEligibilityType = "CONTINGENT_PLAN"
	EnergyPlanContractEligibilityTypeEXISTINGBASICMETER EnergyPlanContractEligibilityType = "EXISTING_BASIC_METER"
	EnergyPlanContractEligibilityTypeEXISTINGBATTERY    EnergyPlanContractEligibilityType = "EXISTING_BATTERY"
	EnergyPlanContractEligibilityTypeEXISTINGCUST       EnergyPlanContractEligibilityType = "EXISTING_CUST"
	EnergyPlanContractEligibilityTypeEXISTINGPOOL       EnergyPlanContractEligibilityType = "EXISTING_POOL"
	EnergyPlanContractEligibilityTypeEXISTINGSMARTMETER EnergyPlanContractEligibilityType = "EXISTING_SMART_METER"
	EnergyPlanContractEligibilityTypeEXISTINGSOLAR      EnergyPlanContractEligibilityType = "EXISTING_SOLAR"
	EnergyPlanContractEligibilityTypeGROUPBUYMEMBER     EnergyPlanContractEligibilityType = "GROUP_BUY_MEMBER"
	EnergyPlanContractEligibilityTypeLOYALTYMEMBER      EnergyPlanContractEligibilityType = "LOYALTY_MEMBER"
	EnergyPlanContractEligibilityTypeMINIMUMUSAGE       EnergyPlanContractEligibilityType = "MINIMUM_USAGE"
	EnergyPlanContractEligibilityTypeNEWCUSTOMER        EnergyPlanContractEligibilityType = "NEW_CUSTOMER"
	EnergyPlanContractEligibilityTypeNOSOLARFIT         EnergyPlanContractEligibilityType = "NO_SOLAR_FIT"
	EnergyPlanContractEligibilityTypeONLINEONLY         EnergyPlanContractEligibilityType = "ONLINE_ONLY"
	EnergyPlanContractEligibilityTypeORGMEMBER          EnergyPlanContractEligibilityType = "ORG_MEMBER"
	EnergyPlanContractEligibilityTypeOTHER              EnergyPlanContractEligibilityType = "OTHER"
	EnergyPlanContractEligibilityTypeREQEQUIPSUPPLIER   EnergyPlanContractEligibilityType = "REQ_EQUIP_SUPPLIER"
	EnergyPlanContractEligibilityTypeSENIORCARD         EnergyPlanContractEligibilityType = "SENIOR_CARD"
	EnergyPlanContractEligibilityTypeSMALLBUSINESS      EnergyPlanContractEligibilityType = "SMALL_BUSINESS"
	EnergyPlanContractEligibilityTypeSPECIFICLOCATION   EnergyPlanContractEligibilityType = "SPECIFIC_LOCATION"
	EnergyPlanContractEligibilityTypeSPORTCLUBMEMBER    EnergyPlanContractEligibilityType = "SPORT_CLUB_MEMBER"
	EnergyPlanContractEligibilityTypeTHIRDPARTYONLY     EnergyPlanContractEligibilityType = "THIRD_PARTY_ONLY"
)

// Defines values for EnergyPlanContractFeesTerm.
const (
	EnergyPlanContractFeesTermANNUAL        EnergyPlanContractFeesTerm = "ANNUAL"
	EnergyPlanContractFeesTermBIANNUAL      EnergyPlanContractFeesTerm = "BIANNUAL"
	EnergyPlanContractFeesTermDAILY         EnergyPlanContractFeesTerm = "DAILY"
	EnergyPlanContractFeesTermFIXED         EnergyPlanContractFeesTerm = "FIXED"
	EnergyPlanContractFeesTermMONTHLY       EnergyPlanContractFeesTerm = "MONTHLY"
	EnergyPlanContractFeesTermN1YEAR        EnergyPlanContractFeesTerm = "1_YEAR"
	EnergyPlanContractFeesTermN2YEAR        EnergyPlanContractFeesTerm = "2_YEAR"
	EnergyPlanContractFeesTermN3YEAR        EnergyPlanContractFeesTerm = "3_YEAR"
	EnergyPlanContractFeesTermN4YEAR        EnergyPlanContractFeesTerm = "4_YEAR"
	EnergyPlanContractFeesTermN5YEAR        EnergyPlanContractFeesTerm = "5_YEAR"
	EnergyPlanContractFeesTermPERCENTOFBILL EnergyPlanContractFeesTerm = "PERCENT_OF_BILL"
	EnergyPlanContractFeesTermVARIABLE      EnergyPlanContractFeesTerm = "VARIABLE"
	EnergyPlanContractFeesTermWEEKLY        EnergyPlanContractFeesTerm = "WEEKLY"
)

// Defines values for EnergyPlanContractFeesType.
const (
	EnergyPlanContractFeesTypeCCPROCESSING      EnergyPlanContractFeesType = "CC_PROCESSING"
	EnergyPlanContractFeesTypeCHEQUEDISHONOUR   EnergyPlanContractFeesType = "CHEQUE_DISHONOUR"
	EnergyPlanContractFeesTypeCONNECTION        EnergyPlanContractFeesType = "CONNECTION"
	EnergyPlanContractFeesTypeCONTRIBUTION      EnergyPlanContractFeesType = "CONTRIBUTION"
	EnergyPlanContractFeesTypeDDDISHONOUR       EnergyPlanContractFeesType = "DD_DISHONOUR"
	EnergyPlanContractFeesTypeDISCONNECTION     EnergyPlanContractFeesType = "DISCONNECTION"
	EnergyPlanContractFeesTypeDISCONNECTMOVEOUT EnergyPlanContractFeesType = "DISCONNECT_MOVE_OUT"
	EnergyPlanContractFeesTypeDISCONNECTNONPAY  EnergyPlanContractFeesType = "DISCONNECT_NON_PAY"
	EnergyPlanContractFeesTypeESTABLISHMENT     EnergyPlanContractFeesType = "ESTABLISHMENT"
	EnergyPlanContractFeesTypeEXIT              EnergyPlanContractFeesType = "EXIT"
	EnergyPlanContractFeesTypeLATEPAYMENT       EnergyPlanContractFeesType = "LATE_PAYMENT"
	EnergyPlanContractFeesTypeMEMBERSHIP        EnergyPlanContractFeesType = "MEMBERSHIP"
	EnergyPlanContractFeesTypeOTHER             EnergyPlanContractFeesType = "OTHER"
	EnergyPlanContractFeesTypePAPERBILL         EnergyPlanContractFeesType = "PAPER_BILL"
	EnergyPlanContractFeesTypePAYMENTPROCESSING EnergyPlanContractFeesType = "PAYMENT_PROCESSING"
	EnergyPlanContractFeesTypeRECONNECTION      EnergyPlanContractFeesType = "RECONNECTION"
)

// Defines values for EnergyPlanContractGreenPowerChargesScheme.
const (
	EnergyPlanContractGreenPowerChargesSchemeGREENPOWER EnergyPlanContractGreenPowerChargesScheme = "GREENPOWER"
	EnergyPlanContractGreenPowerChargesSchemeOTHER      EnergyPlanContractGreenPowerChargesScheme = "OTHER"
)

// Defines values for EnergyPlanContractGreenPowerChargesType.
const (
	EnergyPlanContractGreenPowerChargesTypeFIXEDPERDAY   EnergyPlanContractGreenPowerChargesType = "FIXED_PER_DAY"
	EnergyPlanContractGreenPowerChargesTypeFIXEDPERMONTH EnergyPlanContractGreenPowerChargesType = "FIXED_PER_MONTH"
	EnergyPlanContractGreenPowerChargesTypeFIXEDPERUNIT  EnergyPlanContractGreenPowerChargesType = "FIXED_PER_UNIT"
	EnergyPlanContractGreenPowerChargesTypeFIXEDPERWEEK  EnergyPlanContractGreenPowerChargesType = "FIXED_PER_WEEK"
	EnergyPlanContractGreenPowerChargesTypePERCENTOFBILL EnergyPlanContractGreenPowerChargesType = "PERCENT_OF_BILL"
	EnergyPlanContractGreenPowerChargesTypePERCENTOFUSE  EnergyPlanContractGreenPowerChargesType = "PERCENT_OF_USE"
)

// Defines values for EnergyPlanContractIncentivesCategory.
const (
	EnergyPlanContractIncentivesCategoryACCOUNTCREDIT EnergyPlanContractIncentivesCategory = "ACCOUNT_CREDIT"
	EnergyPlanContractIncentivesCategoryGIFT          EnergyPlanContractIncentivesCategory = "GIFT"
	EnergyPlanContractIncentivesCategoryOTHER         EnergyPlanContractIncentivesCategory = "OTHER"
)

// Defines values for EnergyPlanContractPaymentOption.
const (
	EnergyPlanContractPaymentOptionBPAY        EnergyPlanContractPaymentOption = "BPAY"
	EnergyPlanContractPaymentOptionCREDITCARD  EnergyPlanContractPaymentOption = "CREDIT_CARD"
	EnergyPlanContractPaymentOptionDIRECTDEBIT EnergyPlanContractPaymentOption = "DIRECT_DEBIT"
	EnergyPlanContractPaymentOptionOTHER       EnergyPlanContractPaymentOption = "OTHER"
	EnergyPlanContractPaymentOptionPAPERBILL   EnergyPlanContractPaymentOption = "PAPER_BILL"
)

// Defines values for EnergyPlanContractPricingModel.
const (
	EnergyPlanContractPricingModelFLEXIBLE           EnergyPlanContractPricingModel = "FLEXIBLE"
	EnergyPlanContractPricingModelFLEXIBLECONTLOAD   EnergyPlanContractPricingModel = "FLEXIBLE_CONT_LOAD"
	EnergyPlanContractPricingModelQUOTA              EnergyPlanContractPricingModel = "QUOTA"
	EnergyPlanContractPricingModelSINGLERATE         EnergyPlanContractPricingModel = "SINGLE_RATE"
	EnergyPlanContractPricingModelSINGLERATECONTLOAD EnergyPlanContractPricingModel = "SINGLE_RATE_CONT_LOAD"
	EnergyPlanContractPricingModelTIMEOFUSE          EnergyPlanContractPricingModel = "TIME_OF_USE"
	EnergyPlanContractPricingModelTIMEOFUSECONTLOAD  EnergyPlanContractPricingModel = "TIME_OF_USE_CONT_LOAD"
)

// Defines values for EnergyPlanContractSolarFeedInTariffPayerType.
const (
	EnergyPlanContractSolarFeedInTariffPayerTypeGOVERNMENT EnergyPlanContractSolarFeedInTariffPayerType = "GOVERNMENT"
	EnergyPlanContractSolarFeedInTariffPayerTypeRETAILER   EnergyPlanContractSolarFeedInTariffPayerType = "RETAILER"
)

// Defines values for EnergyPlanContractSolarFeedInTariffScheme.
const (
	EnergyPlanContractSolarFeedInTariffSchemeOTHER   EnergyPlanContractSolarFeedInTariffScheme = "OTHER"
	EnergyPlanContractSolarFeedInTariffSchemePREMIUM EnergyPlanContractSolarFeedInTariffScheme = "PREMIUM"
)

// Defines values for EnergyPlanContractSolarFeedInTariffTariffUType.
const (
	EnergyPlanContractSolarFeedInTariffTariffUTypeSingleTariff       EnergyPlanContractSolarFeedInTariffTariffUType = "singleTariff"
	EnergyPlanContractSolarFeedInTariffTariffUTypeTimeVaryingTariffs EnergyPlanContractSolarFeedInTariffTariffUType = "timeVaryingTariffs"
)

// Defines values for EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays.
const (
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysFRI            EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "FRI"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysMON            EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "MON"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysPUBLICHOLIDAYS EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "PUBLIC_HOLIDAYS"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysSAT            EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "SAT"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysSUN            EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "SUN"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysTHU            EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "THU"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysTUE            EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "TUE"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysWED            EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "WED"
)

// Defines values for EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsType.
const (
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTypeOFFPEAK  EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsType = "OFF_PEAK"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTypePEAK     EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsType = "PEAK"
	EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTypeSHOULDER EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsType = "SHOULDER"
)

// Defines values for EnergyPlanContractTariffPeriodDemandChargesChargePeriod.
const (
	EnergyPlanContractTariffPeriodDemandChargesChargePeriodDAY          EnergyPlanContractTariffPeriodDemandChargesChargePeriod = "DAY"
	EnergyPlanContractTariffPeriodDemandChargesChargePeriodMONTH        EnergyPlanContractTariffPeriodDemandChargesChargePeriod = "MONTH"
	EnergyPlanContractTariffPeriodDemandChargesChargePeriodTARIFFPERIOD EnergyPlanContractTariffPeriodDemandChargesChargePeriod = "TARIFF_PERIOD"
)

// Defines values for EnergyPlanContractTariffPeriodDemandChargesDays.
const (
	EnergyPlanContractTariffPeriodDemandChargesDaysFRI            EnergyPlanContractTariffPeriodDemandChargesDays = "FRI"
	EnergyPlanContractTariffPeriodDemandChargesDaysMON            EnergyPlanContractTariffPeriodDemandChargesDays = "MON"
	EnergyPlanContractTariffPeriodDemandChargesDaysPUBLICHOLIDAYS EnergyPlanContractTariffPeriodDemandChargesDays = "PUBLIC_HOLIDAYS"
	EnergyPlanContractTariffPeriodDemandChargesDaysSAT            EnergyPlanContractTariffPeriodDemandChargesDays = "SAT"
	EnergyPlanContractTariffPeriodDemandChargesDaysSUN            EnergyPlanContractTariffPeriodDemandChargesDays = "SUN"
	EnergyPlanContractTariffPeriodDemandChargesDaysTHU            EnergyPlanContractTariffPeriodDemandChargesDays = "THU"
	EnergyPlanContractTariffPeriodDemandChargesDaysTUE            EnergyPlanContractTariffPeriodDemandChargesDays = "TUE"
	EnergyPlanContractTariffPeriodDemandChargesDaysWED            EnergyPlanContractTariffPeriodDemandChargesDays = "WED"
)

// Defines values for EnergyPlanContractTariffPeriodDemandChargesMeasureUnit.
const (
	EnergyPlanContractTariffPeriodDemandChargesMeasureUnitDAYS  EnergyPlanContractTariffPeriodDemandChargesMeasureUnit = "DAYS"
	EnergyPlanContractTariffPeriodDemandChargesMeasureUnitKVA   EnergyPlanContractTariffPeriodDemandChargesMeasureUnit = "KVA"
	EnergyPlanContractTariffPeriodDemandChargesMeasureUnitKVAR  EnergyPlanContractTariffPeriodDemandChargesMeasureUnit = "KVAR"
	EnergyPlanContractTariffPeriodDemandChargesMeasureUnitKVARH EnergyPlanContractTariffPeriodDemandChargesMeasureUnit = "KVARH"
	EnergyPlanContractTariffPeriodDemandChargesMeasureUnitKW    EnergyPlanContractTariffPeriodDemandChargesMeasureUnit = "KW"
	EnergyPlanContractTariffPeriodDemandChargesMeasureUnitKWH   EnergyPlanContractTariffPeriodDemandChargesMeasureUnit = "KWH"
	EnergyPlanContractTariffPeriodDemandChargesMeasureUnitMETER EnergyPlanContractTariffPeriodDemandChargesMeasureUnit = "METER"
	EnergyPlanContractTariffPeriodDemandChargesMeasureUnitMONTH EnergyPlanContractTariffPeriodDemandChargesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriod.
const (
	EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriodDAY          EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriod = "DAY"
	EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriodMONTH        EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriod = "MONTH"
	EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriodTARIFFPERIOD EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriod = "TARIFF_PERIOD"
)

// Defines values for EnergyPlanContractTariffPeriodRateBlockUType.
const (
	EnergyPlanContractTariffPeriodRateBlockUTypeDemandCharges  EnergyPlanContractTariffPeriodRateBlockUType = "demandCharges"
	EnergyPlanContractTariffPeriodRateBlockUTypeSingleRate     EnergyPlanContractTariffPeriodRateBlockUType = "singleRate"
	EnergyPlanContractTariffPeriodRateBlockUTypeTimeOfUseRates EnergyPlanContractTariffPeriodRateBlockUType = "timeOfUseRates"
)

// Defines values for EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit.
const (
	EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnitDAYS  EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit = "DAYS"
	EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnitKVA   EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit = "KVA"
	EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnitKVAR  EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit = "KVAR"
	EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnitKVARH EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit = "KVARH"
	EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnitKW    EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit = "KW"
	EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnitKWH   EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit = "KWH"
	EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnitMETER EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit = "METER"
	EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnitMONTH EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit.
const (
	EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnitDAYS  EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit = "DAYS"
	EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnitKVA   EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVA"
	EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnitKVAR  EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVAR"
	EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnitKVARH EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVARH"
	EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnitKW    EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KW"
	EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnitKWH   EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KWH"
	EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnitMETER EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit = "METER"
	EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnitMONTH EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays.
const (
	EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDaysFRI            EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays = "FRI"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDaysMON            EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays = "MON"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDaysPUBLICHOLIDAYS EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays = "PUBLIC_HOLIDAYS"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDaysSAT            EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays = "SAT"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDaysSUN            EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays = "SUN"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDaysTHU            EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays = "THU"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDaysTUE            EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays = "TUE"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDaysWED            EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays = "WED"
)

// Defines values for EnergyPlanContractTariffPeriodTimeOfUseRatesType.
const (
	EnergyPlanContractTariffPeriodTimeOfUseRatesTypeOFFPEAK   EnergyPlanContractTariffPeriodTimeOfUseRatesType = "OFF_PEAK"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTypePEAK      EnergyPlanContractTariffPeriodTimeOfUseRatesType = "PEAK"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTypeSHOULDER  EnergyPlanContractTariffPeriodTimeOfUseRatesType = "SHOULDER"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTypeSHOULDER1 EnergyPlanContractTariffPeriodTimeOfUseRatesType = "SHOULDER1"
	EnergyPlanContractTariffPeriodTimeOfUseRatesTypeSHOULDER2 EnergyPlanContractTariffPeriodTimeOfUseRatesType = "SHOULDER2"
)

// Defines values for EnergyPlanContractTariffPeriodTimeZone.
const (
	EnergyPlanContractTariffPeriodTimeZoneAEST  EnergyPlanContractTariffPeriodTimeZone = "AEST"
	EnergyPlanContractTariffPeriodTimeZoneLOCAL EnergyPlanContractTariffPeriodTimeZone = "LOCAL"
)

// Defines values for EnergyPlanContractTariffPeriodType.
const (
	EnergyPlanContractTariffPeriodTypeENVIRONMENTAL EnergyPlanContractTariffPeriodType = "ENVIRONMENTAL"
	EnergyPlanContractTariffPeriodTypeMETERING      EnergyPlanContractTariffPeriodType = "METERING"
	EnergyPlanContractTariffPeriodTypeNETWORK       EnergyPlanContractTariffPeriodType = "NETWORK"
	EnergyPlanContractTariffPeriodTypeOTHER         EnergyPlanContractTariffPeriodType = "OTHER"
	EnergyPlanContractTariffPeriodTypeRCTI          EnergyPlanContractTariffPeriodType = "RCTI"
	EnergyPlanContractTariffPeriodTypeREGULATED     EnergyPlanContractTariffPeriodType = "REGULATED"
	EnergyPlanContractTariffPeriodTypeRETAILSERVICE EnergyPlanContractTariffPeriodType = "RETAIL_SERVICE"
)

// Defines values for EnergyPlanContractTimeZone.
const (
	EnergyPlanContractTimeZoneAEST  EnergyPlanContractTimeZone = "AEST"
	EnergyPlanContractTimeZoneLOCAL EnergyPlanContractTimeZone = "LOCAL"
)

// Defines values for EnergyPlanContractFullControlledLoadRateBlockUType.
const (
	EnergyPlanContractFullControlledLoadRateBlockUTypeSingleRate     EnergyPlanContractFullControlledLoadRateBlockUType = "singleRate"
	EnergyPlanContractFullControlledLoadRateBlockUTypeTimeOfUseRates EnergyPlanContractFullControlledLoadRateBlockUType = "timeOfUseRates"
)

// Defines values for EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit.
const (
	EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnitDAYS  EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit = "DAYS"
	EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnitKVA   EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit = "KVA"
	EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnitKVAR  EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit = "KVAR"
	EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnitKVARH EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit = "KVARH"
	EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnitKW    EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit = "KW"
	EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnitKWH   EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit = "KWH"
	EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnitMETER EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit = "METER"
	EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnitMONTH EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit.
const (
	EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnitDAYS  EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit = "DAYS"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnitKVA   EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVA"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnitKVAR  EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVAR"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnitKVARH EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVARH"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnitKW    EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit = "KW"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnitKWH   EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit = "KWH"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnitMETER EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit = "METER"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnitMONTH EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays.
const (
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDaysFRI            EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays = "FRI"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDaysMON            EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays = "MON"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDaysPUBLICHOLIDAYS EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays = "PUBLIC_HOLIDAYS"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDaysSAT            EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays = "SAT"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDaysSUN            EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays = "SUN"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDaysTHU            EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays = "THU"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDaysTUE            EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays = "TUE"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDaysWED            EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays = "WED"
)

// Defines values for EnergyPlanContractFullControlledLoadTimeOfUseRatesType.
const (
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTypeOFFPEAK     EnergyPlanContractFullControlledLoadTimeOfUseRatesType = "OFF_PEAK"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTypePEAK        EnergyPlanContractFullControlledLoadTimeOfUseRatesType = "PEAK"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTypeSHOULDER    EnergyPlanContractFullControlledLoadTimeOfUseRatesType = "SHOULDER"
	EnergyPlanContractFullControlledLoadTimeOfUseRatesTypeSOLARSPONGE EnergyPlanContractFullControlledLoadTimeOfUseRatesType = "SOLAR_SPONGE"
)

// Defines values for EnergyPlanContractFullDiscountsCategory.
const (
	EnergyPlanContractFullDiscountsCategoryDIRECTDEBIT        EnergyPlanContractFullDiscountsCategory = "DIRECT_DEBIT"
	EnergyPlanContractFullDiscountsCategoryGUARANTEEDDISCOUNT EnergyPlanContractFullDiscountsCategory = "GUARANTEED_DISCOUNT"
	EnergyPlanContractFullDiscountsCategoryOTHER              EnergyPlanContractFullDiscountsCategory = "OTHER"
	EnergyPlanContractFullDiscountsCategoryPAYONTIME          EnergyPlanContractFullDiscountsCategory = "PAY_ON_TIME"
)

// Defines values for EnergyPlanContractFullDiscountsMethodUType.
const (
	EnergyPlanContractFullDiscountsMethodUTypeFixedAmount          EnergyPlanContractFullDiscountsMethodUType = "fixedAmount"
	EnergyPlanContractFullDiscountsMethodUTypePercentOfBill        EnergyPlanContractFullDiscountsMethodUType = "percentOfBill"
	EnergyPlanContractFullDiscountsMethodUTypePercentOfUse         EnergyPlanContractFullDiscountsMethodUType = "percentOfUse"
	EnergyPlanContractFullDiscountsMethodUTypePercentOverThreshold EnergyPlanContractFullDiscountsMethodUType = "percentOverThreshold"
)

// Defines values for EnergyPlanContractFullDiscountsType.
const (
	EnergyPlanContractFullDiscountsTypeCONDITIONAL EnergyPlanContractFullDiscountsType = "CONDITIONAL"
	EnergyPlanContractFullDiscountsTypeGUARANTEED  EnergyPlanContractFullDiscountsType = "GUARANTEED"
	EnergyPlanContractFullDiscountsTypeOTHER       EnergyPlanContractFullDiscountsType = "OTHER"
)

// Defines values for EnergyPlanContractFullEligibilityType.
const (
	EnergyPlanContractFullEligibilityTypeCONTINGENTPLAN     EnergyPlanContractFullEligibilityType = "CONTINGENT_PLAN"
	EnergyPlanContractFullEligibilityTypeEXISTINGBASICMETER EnergyPlanContractFullEligibilityType = "EXISTING_BASIC_METER"
	EnergyPlanContractFullEligibilityTypeEXISTINGBATTERY    EnergyPlanContractFullEligibilityType = "EXISTING_BATTERY"
	EnergyPlanContractFullEligibilityTypeEXISTINGCUST       EnergyPlanContractFullEligibilityType = "EXISTING_CUST"
	EnergyPlanContractFullEligibilityTypeEXISTINGPOOL       EnergyPlanContractFullEligibilityType = "EXISTING_POOL"
	EnergyPlanContractFullEligibilityTypeEXISTINGSMARTMETER EnergyPlanContractFullEligibilityType = "EXISTING_SMART_METER"
	EnergyPlanContractFullEligibilityTypeEXISTINGSOLAR      EnergyPlanContractFullEligibilityType = "EXISTING_SOLAR"
	EnergyPlanContractFullEligibilityTypeGROUPBUYMEMBER     EnergyPlanContractFullEligibilityType = "GROUP_BUY_MEMBER"
	EnergyPlanContractFullEligibilityTypeLOYALTYMEMBER      EnergyPlanContractFullEligibilityType = "LOYALTY_MEMBER"
	EnergyPlanContractFullEligibilityTypeMINIMUMUSAGE       EnergyPlanContractFullEligibilityType = "MINIMUM_USAGE"
	EnergyPlanContractFullEligibilityTypeNEWCUSTOMER        EnergyPlanContractFullEligibilityType = "NEW_CUSTOMER"
	EnergyPlanContractFullEligibilityTypeNOSOLARFIT         EnergyPlanContractFullEligibilityType = "NO_SOLAR_FIT"
	EnergyPlanContractFullEligibilityTypeONLINEONLY         EnergyPlanContractFullEligibilityType = "ONLINE_ONLY"
	EnergyPlanContractFullEligibilityTypeORGMEMBER          EnergyPlanContractFullEligibilityType = "ORG_MEMBER"
	EnergyPlanContractFullEligibilityTypeOTHER              EnergyPlanContractFullEligibilityType = "OTHER"
	EnergyPlanContractFullEligibilityTypeREQEQUIPSUPPLIER   EnergyPlanContractFullEligibilityType = "REQ_EQUIP_SUPPLIER"
	EnergyPlanContractFullEligibilityTypeSENIORCARD         EnergyPlanContractFullEligibilityType = "SENIOR_CARD"
	EnergyPlanContractFullEligibilityTypeSMALLBUSINESS      EnergyPlanContractFullEligibilityType = "SMALL_BUSINESS"
	EnergyPlanContractFullEligibilityTypeSPECIFICLOCATION   EnergyPlanContractFullEligibilityType = "SPECIFIC_LOCATION"
	EnergyPlanContractFullEligibilityTypeSPORTCLUBMEMBER    EnergyPlanContractFullEligibilityType = "SPORT_CLUB_MEMBER"
	EnergyPlanContractFullEligibilityTypeTHIRDPARTYONLY     EnergyPlanContractFullEligibilityType = "THIRD_PARTY_ONLY"
)

// Defines values for EnergyPlanContractFullFeesTerm.
const (
	EnergyPlanContractFullFeesTermANNUAL        EnergyPlanContractFullFeesTerm = "ANNUAL"
	EnergyPlanContractFullFeesTermBIANNUAL      EnergyPlanContractFullFeesTerm = "BIANNUAL"
	EnergyPlanContractFullFeesTermDAILY         EnergyPlanContractFullFeesTerm = "DAILY"
	EnergyPlanContractFullFeesTermFIXED         EnergyPlanContractFullFeesTerm = "FIXED"
	EnergyPlanContractFullFeesTermMONTHLY       EnergyPlanContractFullFeesTerm = "MONTHLY"
	EnergyPlanContractFullFeesTermN1YEAR        EnergyPlanContractFullFeesTerm = "1_YEAR"
	EnergyPlanContractFullFeesTermN2YEAR        EnergyPlanContractFullFeesTerm = "2_YEAR"
	EnergyPlanContractFullFeesTermN3YEAR        EnergyPlanContractFullFeesTerm = "3_YEAR"
	EnergyPlanContractFullFeesTermN4YEAR        EnergyPlanContractFullFeesTerm = "4_YEAR"
	EnergyPlanContractFullFeesTermN5YEAR        EnergyPlanContractFullFeesTerm = "5_YEAR"
	EnergyPlanContractFullFeesTermPERCENTOFBILL EnergyPlanContractFullFeesTerm = "PERCENT_OF_BILL"
	EnergyPlanContractFullFeesTermVARIABLE      EnergyPlanContractFullFeesTerm = "VARIABLE"
	EnergyPlanContractFullFeesTermWEEKLY        EnergyPlanContractFullFeesTerm = "WEEKLY"
)

// Defines values for EnergyPlanContractFullFeesType.
const (
	EnergyPlanContractFullFeesTypeCCPROCESSING      EnergyPlanContractFullFeesType = "CC_PROCESSING"
	EnergyPlanContractFullFeesTypeCHEQUEDISHONOUR   EnergyPlanContractFullFeesType = "CHEQUE_DISHONOUR"
	EnergyPlanContractFullFeesTypeCONNECTION        EnergyPlanContractFullFeesType = "CONNECTION"
	EnergyPlanContractFullFeesTypeCONTRIBUTION      EnergyPlanContractFullFeesType = "CONTRIBUTION"
	EnergyPlanContractFullFeesTypeDDDISHONOUR       EnergyPlanContractFullFeesType = "DD_DISHONOUR"
	EnergyPlanContractFullFeesTypeDISCONNECTION     EnergyPlanContractFullFeesType = "DISCONNECTION"
	EnergyPlanContractFullFeesTypeDISCONNECTMOVEOUT EnergyPlanContractFullFeesType = "DISCONNECT_MOVE_OUT"
	EnergyPlanContractFullFeesTypeDISCONNECTNONPAY  EnergyPlanContractFullFeesType = "DISCONNECT_NON_PAY"
	EnergyPlanContractFullFeesTypeESTABLISHMENT     EnergyPlanContractFullFeesType = "ESTABLISHMENT"
	EnergyPlanContractFullFeesTypeEXIT              EnergyPlanContractFullFeesType = "EXIT"
	EnergyPlanContractFullFeesTypeLATEPAYMENT       EnergyPlanContractFullFeesType = "LATE_PAYMENT"
	EnergyPlanContractFullFeesTypeMEMBERSHIP        EnergyPlanContractFullFeesType = "MEMBERSHIP"
	EnergyPlanContractFullFeesTypeOTHER             EnergyPlanContractFullFeesType = "OTHER"
	EnergyPlanContractFullFeesTypePAPERBILL         EnergyPlanContractFullFeesType = "PAPER_BILL"
	EnergyPlanContractFullFeesTypePAYMENTPROCESSING EnergyPlanContractFullFeesType = "PAYMENT_PROCESSING"
	EnergyPlanContractFullFeesTypeRECONNECTION      EnergyPlanContractFullFeesType = "RECONNECTION"
)

// Defines values for EnergyPlanContractFullGreenPowerChargesScheme.
const (
	EnergyPlanContractFullGreenPowerChargesSchemeGREENPOWER EnergyPlanContractFullGreenPowerChargesScheme = "GREENPOWER"
	EnergyPlanContractFullGreenPowerChargesSchemeOTHER      EnergyPlanContractFullGreenPowerChargesScheme = "OTHER"
)

// Defines values for EnergyPlanContractFullGreenPowerChargesType.
const (
	FIXEDPERDAY   EnergyPlanContractFullGreenPowerChargesType = "FIXED_PER_DAY"
	FIXEDPERMONTH EnergyPlanContractFullGreenPowerChargesType = "FIXED_PER_MONTH"
	FIXEDPERUNIT  EnergyPlanContractFullGreenPowerChargesType = "FIXED_PER_UNIT"
	FIXEDPERWEEK  EnergyPlanContractFullGreenPowerChargesType = "FIXED_PER_WEEK"
	PERCENTOFBILL EnergyPlanContractFullGreenPowerChargesType = "PERCENT_OF_BILL"
	PERCENTOFUSE  EnergyPlanContractFullGreenPowerChargesType = "PERCENT_OF_USE"
)

// Defines values for EnergyPlanContractFullIncentivesCategory.
const (
	EnergyPlanContractFullIncentivesCategoryACCOUNTCREDIT EnergyPlanContractFullIncentivesCategory = "ACCOUNT_CREDIT"
	EnergyPlanContractFullIncentivesCategoryGIFT          EnergyPlanContractFullIncentivesCategory = "GIFT"
	EnergyPlanContractFullIncentivesCategoryOTHER         EnergyPlanContractFullIncentivesCategory = "OTHER"
)

// Defines values for EnergyPlanContractFullPaymentOption.
const (
	EnergyPlanContractFullPaymentOptionBPAY        EnergyPlanContractFullPaymentOption = "BPAY"
	EnergyPlanContractFullPaymentOptionCREDITCARD  EnergyPlanContractFullPaymentOption = "CREDIT_CARD"
	EnergyPlanContractFullPaymentOptionDIRECTDEBIT EnergyPlanContractFullPaymentOption = "DIRECT_DEBIT"
	EnergyPlanContractFullPaymentOptionOTHER       EnergyPlanContractFullPaymentOption = "OTHER"
	EnergyPlanContractFullPaymentOptionPAPERBILL   EnergyPlanContractFullPaymentOption = "PAPER_BILL"
)

// Defines values for EnergyPlanContractFullPricingModel.
const (
	EnergyPlanContractFullPricingModelFLEXIBLE           EnergyPlanContractFullPricingModel = "FLEXIBLE"
	EnergyPlanContractFullPricingModelFLEXIBLECONTLOAD   EnergyPlanContractFullPricingModel = "FLEXIBLE_CONT_LOAD"
	EnergyPlanContractFullPricingModelQUOTA              EnergyPlanContractFullPricingModel = "QUOTA"
	EnergyPlanContractFullPricingModelSINGLERATE         EnergyPlanContractFullPricingModel = "SINGLE_RATE"
	EnergyPlanContractFullPricingModelSINGLERATECONTLOAD EnergyPlanContractFullPricingModel = "SINGLE_RATE_CONT_LOAD"
	EnergyPlanContractFullPricingModelTIMEOFUSE          EnergyPlanContractFullPricingModel = "TIME_OF_USE"
	EnergyPlanContractFullPricingModelTIMEOFUSECONTLOAD  EnergyPlanContractFullPricingModel = "TIME_OF_USE_CONT_LOAD"
)

// Defines values for EnergyPlanContractFullSolarFeedInTariffPayerType.
const (
	EnergyPlanContractFullSolarFeedInTariffPayerTypeGOVERNMENT EnergyPlanContractFullSolarFeedInTariffPayerType = "GOVERNMENT"
	EnergyPlanContractFullSolarFeedInTariffPayerTypeRETAILER   EnergyPlanContractFullSolarFeedInTariffPayerType = "RETAILER"
)

// Defines values for EnergyPlanContractFullSolarFeedInTariffScheme.
const (
	EnergyPlanContractFullSolarFeedInTariffSchemeOTHER   EnergyPlanContractFullSolarFeedInTariffScheme = "OTHER"
	EnergyPlanContractFullSolarFeedInTariffSchemePREMIUM EnergyPlanContractFullSolarFeedInTariffScheme = "PREMIUM"
)

// Defines values for EnergyPlanContractFullSolarFeedInTariffTariffUType.
const (
	EnergyPlanContractFullSolarFeedInTariffTariffUTypeSingleTariff       EnergyPlanContractFullSolarFeedInTariffTariffUType = "singleTariff"
	EnergyPlanContractFullSolarFeedInTariffTariffUTypeTimeVaryingTariffs EnergyPlanContractFullSolarFeedInTariffTariffUType = "timeVaryingTariffs"
)

// Defines values for EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays.
const (
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysFRI            EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "FRI"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysMON            EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "MON"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysPUBLICHOLIDAYS EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "PUBLIC_HOLIDAYS"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysSAT            EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "SAT"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysSUN            EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "SUN"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysTHU            EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "THU"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysTUE            EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "TUE"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysWED            EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "WED"
)

// Defines values for EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsType.
const (
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTypeOFFPEAK  EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsType = "OFF_PEAK"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTypePEAK     EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsType = "PEAK"
	EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTypeSHOULDER EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsType = "SHOULDER"
)

// Defines values for EnergyPlanContractFullTariffPeriodDemandChargesChargePeriod.
const (
	EnergyPlanContractFullTariffPeriodDemandChargesChargePeriodDAY          EnergyPlanContractFullTariffPeriodDemandChargesChargePeriod = "DAY"
	EnergyPlanContractFullTariffPeriodDemandChargesChargePeriodMONTH        EnergyPlanContractFullTariffPeriodDemandChargesChargePeriod = "MONTH"
	EnergyPlanContractFullTariffPeriodDemandChargesChargePeriodTARIFFPERIOD EnergyPlanContractFullTariffPeriodDemandChargesChargePeriod = "TARIFF_PERIOD"
)

// Defines values for EnergyPlanContractFullTariffPeriodDemandChargesDays.
const (
	EnergyPlanContractFullTariffPeriodDemandChargesDaysFRI            EnergyPlanContractFullTariffPeriodDemandChargesDays = "FRI"
	EnergyPlanContractFullTariffPeriodDemandChargesDaysMON            EnergyPlanContractFullTariffPeriodDemandChargesDays = "MON"
	EnergyPlanContractFullTariffPeriodDemandChargesDaysPUBLICHOLIDAYS EnergyPlanContractFullTariffPeriodDemandChargesDays = "PUBLIC_HOLIDAYS"
	EnergyPlanContractFullTariffPeriodDemandChargesDaysSAT            EnergyPlanContractFullTariffPeriodDemandChargesDays = "SAT"
	EnergyPlanContractFullTariffPeriodDemandChargesDaysSUN            EnergyPlanContractFullTariffPeriodDemandChargesDays = "SUN"
	EnergyPlanContractFullTariffPeriodDemandChargesDaysTHU            EnergyPlanContractFullTariffPeriodDemandChargesDays = "THU"
	EnergyPlanContractFullTariffPeriodDemandChargesDaysTUE            EnergyPlanContractFullTariffPeriodDemandChargesDays = "TUE"
	EnergyPlanContractFullTariffPeriodDemandChargesDaysWED            EnergyPlanContractFullTariffPeriodDemandChargesDays = "WED"
)

// Defines values for EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit.
const (
	EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnitDAYS  EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit = "DAYS"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnitKVA   EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit = "KVA"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnitKVAR  EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit = "KVAR"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnitKVARH EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit = "KVARH"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnitKW    EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit = "KW"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnitKWH   EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit = "KWH"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnitMETER EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit = "METER"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnitMONTH EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriod.
const (
	EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriodDAY          EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriod = "DAY"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriodMONTH        EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriod = "MONTH"
	EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriodTARIFFPERIOD EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriod = "TARIFF_PERIOD"
)

// Defines values for EnergyPlanContractFullTariffPeriodRateBlockUType.
const (
	EnergyPlanContractFullTariffPeriodRateBlockUTypeDemandCharges  EnergyPlanContractFullTariffPeriodRateBlockUType = "demandCharges"
	EnergyPlanContractFullTariffPeriodRateBlockUTypeSingleRate     EnergyPlanContractFullTariffPeriodRateBlockUType = "singleRate"
	EnergyPlanContractFullTariffPeriodRateBlockUTypeTimeOfUseRates EnergyPlanContractFullTariffPeriodRateBlockUType = "timeOfUseRates"
)

// Defines values for EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit.
const (
	EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnitDAYS  EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit = "DAYS"
	EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnitKVA   EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit = "KVA"
	EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnitKVAR  EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit = "KVAR"
	EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnitKVARH EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit = "KVARH"
	EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnitKW    EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit = "KW"
	EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnitKWH   EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit = "KWH"
	EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnitMETER EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit = "METER"
	EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnitMONTH EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit.
const (
	DAYS  EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit = "DAYS"
	KVA   EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVA"
	KVAR  EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVAR"
	KVARH EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVARH"
	KW    EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KW"
	KWH   EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KWH"
	METER EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit = "METER"
	MONTH EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays.
const (
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDaysFRI            EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays = "FRI"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDaysMON            EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays = "MON"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDaysPUBLICHOLIDAYS EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays = "PUBLIC_HOLIDAYS"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDaysSAT            EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays = "SAT"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDaysSUN            EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays = "SUN"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDaysTHU            EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays = "THU"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDaysTUE            EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays = "TUE"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDaysWED            EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays = "WED"
)

// Defines values for EnergyPlanContractFullTariffPeriodTimeOfUseRatesType.
const (
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTypeOFFPEAK   EnergyPlanContractFullTariffPeriodTimeOfUseRatesType = "OFF_PEAK"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTypePEAK      EnergyPlanContractFullTariffPeriodTimeOfUseRatesType = "PEAK"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTypeSHOULDER  EnergyPlanContractFullTariffPeriodTimeOfUseRatesType = "SHOULDER"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTypeSHOULDER1 EnergyPlanContractFullTariffPeriodTimeOfUseRatesType = "SHOULDER1"
	EnergyPlanContractFullTariffPeriodTimeOfUseRatesTypeSHOULDER2 EnergyPlanContractFullTariffPeriodTimeOfUseRatesType = "SHOULDER2"
)

// Defines values for EnergyPlanContractFullTariffPeriodTimeZone.
const (
	EnergyPlanContractFullTariffPeriodTimeZoneAEST  EnergyPlanContractFullTariffPeriodTimeZone = "AEST"
	EnergyPlanContractFullTariffPeriodTimeZoneLOCAL EnergyPlanContractFullTariffPeriodTimeZone = "LOCAL"
)

// Defines values for EnergyPlanContractFullTariffPeriodType.
const (
	EnergyPlanContractFullTariffPeriodTypeENVIRONMENTAL EnergyPlanContractFullTariffPeriodType = "ENVIRONMENTAL"
	EnergyPlanContractFullTariffPeriodTypeMETERING      EnergyPlanContractFullTariffPeriodType = "METERING"
	EnergyPlanContractFullTariffPeriodTypeNETWORK       EnergyPlanContractFullTariffPeriodType = "NETWORK"
	EnergyPlanContractFullTariffPeriodTypeOTHER         EnergyPlanContractFullTariffPeriodType = "OTHER"
	EnergyPlanContractFullTariffPeriodTypeRCTI          EnergyPlanContractFullTariffPeriodType = "RCTI"
	EnergyPlanContractFullTariffPeriodTypeREGULATED     EnergyPlanContractFullTariffPeriodType = "REGULATED"
	EnergyPlanContractFullTariffPeriodTypeRETAILSERVICE EnergyPlanContractFullTariffPeriodType = "RETAIL_SERVICE"
)

// Defines values for EnergyPlanContractFullTermType.
const (
	EnergyPlanContractFullTermTypeN1YEAR  EnergyPlanContractFullTermType = "1_YEAR"
	EnergyPlanContractFullTermTypeN2YEAR  EnergyPlanContractFullTermType = "2_YEAR"
	EnergyPlanContractFullTermTypeN3YEAR  EnergyPlanContractFullTermType = "3_YEAR"
	EnergyPlanContractFullTermTypeN4YEAR  EnergyPlanContractFullTermType = "4_YEAR"
	EnergyPlanContractFullTermTypeN5YEAR  EnergyPlanContractFullTermType = "5_YEAR"
	EnergyPlanContractFullTermTypeONGOING EnergyPlanContractFullTermType = "ONGOING"
	EnergyPlanContractFullTermTypeOTHER   EnergyPlanContractFullTermType = "OTHER"
)

// Defines values for EnergyPlanContractFullTimeZone.
const (
	EnergyPlanContractFullTimeZoneAEST  EnergyPlanContractFullTimeZone = "AEST"
	EnergyPlanContractFullTimeZoneLOCAL EnergyPlanContractFullTimeZone = "LOCAL"
)

// Defines values for EnergyPlanContractFullAllOfTermType.
const (
	EnergyPlanContractFullAllOfTermTypeN1YEAR  EnergyPlanContractFullAllOfTermType = "1_YEAR"
	EnergyPlanContractFullAllOfTermTypeN2YEAR  EnergyPlanContractFullAllOfTermType = "2_YEAR"
	EnergyPlanContractFullAllOfTermTypeN3YEAR  EnergyPlanContractFullAllOfTermType = "3_YEAR"
	EnergyPlanContractFullAllOfTermTypeN4YEAR  EnergyPlanContractFullAllOfTermType = "4_YEAR"
	EnergyPlanContractFullAllOfTermTypeN5YEAR  EnergyPlanContractFullAllOfTermType = "5_YEAR"
	EnergyPlanContractFullAllOfTermTypeONGOING EnergyPlanContractFullAllOfTermType = "ONGOING"
	EnergyPlanContractFullAllOfTermTypeOTHER   EnergyPlanContractFullAllOfTermType = "OTHER"
)

// Defines values for EnergyPlanDetailCustomerType.
const (
	EnergyPlanDetailCustomerTypeBUSINESS    EnergyPlanDetailCustomerType = "BUSINESS"
	EnergyPlanDetailCustomerTypeRESIDENTIAL EnergyPlanDetailCustomerType = "RESIDENTIAL"
)

// Defines values for EnergyPlanDetailFuelType.
const (
	EnergyPlanDetailFuelTypeDUAL        EnergyPlanDetailFuelType = "DUAL"
	EnergyPlanDetailFuelTypeELECTRICITY EnergyPlanDetailFuelType = "ELECTRICITY"
	EnergyPlanDetailFuelTypeGAS         EnergyPlanDetailFuelType = "GAS"
)

// Defines values for EnergyPlanDetailType.
const (
	EnergyPlanDetailTypeMARKET    EnergyPlanDetailType = "MARKET"
	EnergyPlanDetailTypeREGULATED EnergyPlanDetailType = "REGULATED"
	EnergyPlanDetailTypeSTANDING  EnergyPlanDetailType = "STANDING"
)

// Defines values for EnergyServicePointJurisdictionCode.
const (
	EnergyServicePointJurisdictionCodeACT EnergyServicePointJurisdictionCode = "ACT"
	EnergyServicePointJurisdictionCodeALL EnergyServicePointJurisdictionCode = "ALL"
	EnergyServicePointJurisdictionCodeNEM EnergyServicePointJurisdictionCode = "NEM"
	EnergyServicePointJurisdictionCodeNSW EnergyServicePointJurisdictionCode = "NSW"
	EnergyServicePointJurisdictionCodeQLD EnergyServicePointJurisdictionCode = "QLD"
	EnergyServicePointJurisdictionCodeSA  EnergyServicePointJurisdictionCode = "SA"
	EnergyServicePointJurisdictionCodeTAS EnergyServicePointJurisdictionCode = "TAS"
	EnergyServicePointJurisdictionCodeVIC EnergyServicePointJurisdictionCode = "VIC"
)

// Defines values for EnergyServicePointServicePointClassification.
const (
	EnergyServicePointServicePointClassificationDISTRIBUTIONWHOLESALE          EnergyServicePointServicePointClassification = "DISTRIBUTION_WHOLESALE"
	EnergyServicePointServicePointClassificationEXTERNALPROFILE                EnergyServicePointServicePointClassification = "EXTERNAL_PROFILE"
	EnergyServicePointServicePointClassificationGENERATOR                      EnergyServicePointServicePointClassification = "GENERATOR"
	EnergyServicePointServicePointClassificationLARGE                          EnergyServicePointServicePointClassification = "LARGE"
	EnergyServicePointServicePointClassificationNONCONTESTUNMETEREDLOAD        EnergyServicePointServicePointClassification = "NON_CONTEST_UNMETERED_LOAD"
	EnergyServicePointServicePointClassificationNONREGISTEREDEMBEDDEDGENERATOR EnergyServicePointServicePointClassification = "NON_REGISTERED_EMBEDDED_GENERATOR"
	EnergyServicePointServicePointClassificationSMALL                          EnergyServicePointServicePointClassification = "SMALL"
	EnergyServicePointServicePointClassificationWHOLESALE                      EnergyServicePointServicePointClassification = "WHOLESALE"
)

// Defines values for EnergyServicePointServicePointStatus.
const (
	EnergyServicePointServicePointStatusACTIVE      EnergyServicePointServicePointStatus = "ACTIVE"
	EnergyServicePointServicePointStatusDEENERGISED EnergyServicePointServicePointStatus = "DE_ENERGISED"
	EnergyServicePointServicePointStatusEXTINCT     EnergyServicePointServicePointStatus = "EXTINCT"
	EnergyServicePointServicePointStatusGREENFIELD  EnergyServicePointServicePointStatus = "GREENFIELD"
	EnergyServicePointServicePointStatusOFFMARKET   EnergyServicePointServicePointStatus = "OFF_MARKET"
)

// Defines values for EnergyServicePointDetailJurisdictionCode.
const (
	EnergyServicePointDetailJurisdictionCodeACT EnergyServicePointDetailJurisdictionCode = "ACT"
	EnergyServicePointDetailJurisdictionCodeALL EnergyServicePointDetailJurisdictionCode = "ALL"
	EnergyServicePointDetailJurisdictionCodeNEM EnergyServicePointDetailJurisdictionCode = "NEM"
	EnergyServicePointDetailJurisdictionCodeNSW EnergyServicePointDetailJurisdictionCode = "NSW"
	EnergyServicePointDetailJurisdictionCodeQLD EnergyServicePointDetailJurisdictionCode = "QLD"
	EnergyServicePointDetailJurisdictionCodeSA  EnergyServicePointDetailJurisdictionCode = "SA"
	EnergyServicePointDetailJurisdictionCodeTAS EnergyServicePointDetailJurisdictionCode = "TAS"
	EnergyServicePointDetailJurisdictionCodeVIC EnergyServicePointDetailJurisdictionCode = "VIC"
)

// Defines values for EnergyServicePointDetailServicePointClassification.
const (
	EnergyServicePointDetailServicePointClassificationDISTRIBUTIONWHOLESALE          EnergyServicePointDetailServicePointClassification = "DISTRIBUTION_WHOLESALE"
	EnergyServicePointDetailServicePointClassificationEXTERNALPROFILE                EnergyServicePointDetailServicePointClassification = "EXTERNAL_PROFILE"
	EnergyServicePointDetailServicePointClassificationGENERATOR                      EnergyServicePointDetailServicePointClassification = "GENERATOR"
	EnergyServicePointDetailServicePointClassificationLARGE                          EnergyServicePointDetailServicePointClassification = "LARGE"
	EnergyServicePointDetailServicePointClassificationNONCONTESTUNMETEREDLOAD        EnergyServicePointDetailServicePointClassification = "NON_CONTEST_UNMETERED_LOAD"
	EnergyServicePointDetailServicePointClassificationNONREGISTEREDEMBEDDEDGENERATOR EnergyServicePointDetailServicePointClassification = "NON_REGISTERED_EMBEDDED_GENERATOR"
	EnergyServicePointDetailServicePointClassificationSMALL                          EnergyServicePointDetailServicePointClassification = "SMALL"
	EnergyServicePointDetailServicePointClassificationWHOLESALE                      EnergyServicePointDetailServicePointClassification = "WHOLESALE"
)

// Defines values for EnergyServicePointDetailServicePointStatus.
const (
	EnergyServicePointDetailServicePointStatusACTIVE      EnergyServicePointDetailServicePointStatus = "ACTIVE"
	EnergyServicePointDetailServicePointStatusDEENERGISED EnergyServicePointDetailServicePointStatus = "DE_ENERGISED"
	EnergyServicePointDetailServicePointStatusEXTINCT     EnergyServicePointDetailServicePointStatus = "EXTINCT"
	EnergyServicePointDetailServicePointStatusGREENFIELD  EnergyServicePointDetailServicePointStatus = "GREENFIELD"
	EnergyServicePointDetailServicePointStatusOFFMARKET   EnergyServicePointDetailServicePointStatus = "OFF_MARKET"
)

// Defines values for EnergyServicePointDetailRegistersConsumptionType.
const (
	EnergyServicePointDetailRegistersConsumptionTypeACTUAL     EnergyServicePointDetailRegistersConsumptionType = "ACTUAL"
	EnergyServicePointDetailRegistersConsumptionTypeCUMULATIVE EnergyServicePointDetailRegistersConsumptionType = "CUMULATIVE"
)

// Defines values for EnergyServicePointDetailRegistersRegisterConsumptionType.
const (
	EnergyServicePointDetailRegistersRegisterConsumptionTypeACTIVE         EnergyServicePointDetailRegistersRegisterConsumptionType = "ACTIVE"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeACTIVEIMPORT   EnergyServicePointDetailRegistersRegisterConsumptionType = "ACTIVE_IMPORT"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeBASIC          EnergyServicePointDetailRegistersRegisterConsumptionType = "BASIC"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeINTERVAL       EnergyServicePointDetailRegistersRegisterConsumptionType = "INTERVAL"
	EnergyServicePointDetailRegistersRegisterConsumptionTypePROFILEDATA    EnergyServicePointDetailRegistersRegisterConsumptionType = "PROFILE_DATA"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeREACTIVE       EnergyServicePointDetailRegistersRegisterConsumptionType = "REACTIVE"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeREACTIVEIMPORT EnergyServicePointDetailRegistersRegisterConsumptionType = "REACTIVE_IMPORT"
)

// Defines values for EnergyServicePointDetailRegistersTimeOfDay.
const (
	EnergyServicePointDetailRegistersTimeOfDayALLDAY     EnergyServicePointDetailRegistersTimeOfDay = "ALLDAY"
	EnergyServicePointDetailRegistersTimeOfDayBUSINESS   EnergyServicePointDetailRegistersTimeOfDay = "BUSINESS"
	EnergyServicePointDetailRegistersTimeOfDayCONTROLLED EnergyServicePointDetailRegistersTimeOfDay = "CONTROLLED"
	EnergyServicePointDetailRegistersTimeOfDayDEMAND     EnergyServicePointDetailRegistersTimeOfDay = "DEMAND"
	EnergyServicePointDetailRegistersTimeOfDayEVENING    EnergyServicePointDetailRegistersTimeOfDay = "EVENING"
	EnergyServicePointDetailRegistersTimeOfDayINTERVAL   EnergyServicePointDetailRegistersTimeOfDay = "INTERVAL"
	EnergyServicePointDetailRegistersTimeOfDayOFFPEAK    EnergyServicePointDetailRegistersTimeOfDay = "OFFPEAK"
	EnergyServicePointDetailRegistersTimeOfDayPEAK       EnergyServicePointDetailRegistersTimeOfDay = "PEAK"
	EnergyServicePointDetailRegistersTimeOfDaySHOULDER   EnergyServicePointDetailRegistersTimeOfDay = "SHOULDER"
)

// Defines values for EnergyServicePointDetailRelatedParticipantsRole.
const (
	DRSP EnergyServicePointDetailRelatedParticipantsRole = "DRSP"
	FRMP EnergyServicePointDetailRelatedParticipantsRole = "FRMP"
	LNSP EnergyServicePointDetailRelatedParticipantsRole = "LNSP"
)

// Defines values for EnergyServicePointDetailSpecificationsInstallationType.
const (
	BASIC    EnergyServicePointDetailSpecificationsInstallationType = "BASIC"
	COMMS1   EnergyServicePointDetailSpecificationsInstallationType = "COMMS1"
	COMMS2   EnergyServicePointDetailSpecificationsInstallationType = "COMMS2"
	COMMS3   EnergyServicePointDetailSpecificationsInstallationType = "COMMS3"
	COMMS4   EnergyServicePointDetailSpecificationsInstallationType = "COMMS4"
	COMMS4C  EnergyServicePointDetailSpecificationsInstallationType = "COMMS4C"
	COMMS4D  EnergyServicePointDetailSpecificationsInstallationType = "COMMS4D"
	MRAM     EnergyServicePointDetailSpecificationsInstallationType = "MRAM"
	MRIM     EnergyServicePointDetailSpecificationsInstallationType = "MRIM"
	NCOLNUML EnergyServicePointDetailSpecificationsInstallationType = "NCOLNUML"
	PROF     EnergyServicePointDetailSpecificationsInstallationType = "PROF"
	SAMPLE   EnergyServicePointDetailSpecificationsInstallationType = "SAMPLE"
	UMCP     EnergyServicePointDetailSpecificationsInstallationType = "UMCP"
	VICAMI   EnergyServicePointDetailSpecificationsInstallationType = "VICAMI"
)

// Defines values for EnergyServicePointDetailSpecificationsStatus.
const (
	EnergyServicePointDetailSpecificationsStatusCURRENT      EnergyServicePointDetailSpecificationsStatus = "CURRENT"
	EnergyServicePointDetailSpecificationsStatusDISCONNECTED EnergyServicePointDetailSpecificationsStatus = "DISCONNECTED"
)

// Defines values for EnergyServicePointConsumerProfileClassification.
const (
	BUSINESS    EnergyServicePointConsumerProfileClassification = "BUSINESS"
	RESIDENTIAL EnergyServicePointConsumerProfileClassification = "RESIDENTIAL"
)

// Defines values for EnergyServicePointConsumerProfileThreshold.
const (
	HIGH   EnergyServicePointConsumerProfileThreshold = "HIGH"
	LOW    EnergyServicePointConsumerProfileThreshold = "LOW"
	MEDIUM EnergyServicePointConsumerProfileThreshold = "MEDIUM"
)

// Defines values for EnergyUsageReadReadUType.
const (
	BasicRead    EnergyUsageReadReadUType = "basicRead"
	IntervalRead EnergyUsageReadReadUType = "intervalRead"
)

// Defines values for EnergyUsageReadBasicReadQuality.
const (
	EnergyUsageReadBasicReadQualityACTUAL          EnergyUsageReadBasicReadQuality = "ACTUAL"
	EnergyUsageReadBasicReadQualityFINALSUBSTITUTE EnergyUsageReadBasicReadQuality = "FINAL_SUBSTITUTE"
	EnergyUsageReadBasicReadQualitySUBSTITUTE      EnergyUsageReadBasicReadQuality = "SUBSTITUTE"
)

// Defines values for EnergyUsageReadIntervalReadReadQualitiesQuality.
const (
	FINALSUBSTITUTE EnergyUsageReadIntervalReadReadQualitiesQuality = "FINAL_SUBSTITUTE"
	SUBSTITUTE      EnergyUsageReadIntervalReadReadQualitiesQuality = "SUBSTITUTE"
)

// Defines values for ListAccountsParamsOpenStatus.
const (
	ListAccountsParamsOpenStatusALL    ListAccountsParamsOpenStatus = "ALL"
	ListAccountsParamsOpenStatusCLOSED ListAccountsParamsOpenStatus = "CLOSED"
	ListAccountsParamsOpenStatusOPEN   ListAccountsParamsOpenStatus = "OPEN"
)

// Defines values for ListUsageBulkParamsIntervalReads.
const (
	ListUsageBulkParamsIntervalReadsFULL  ListUsageBulkParamsIntervalReads = "FULL"
	ListUsageBulkParamsIntervalReadsMIN30 ListUsageBulkParamsIntervalReads = "MIN_30"
	ListUsageBulkParamsIntervalReadsNONE  ListUsageBulkParamsIntervalReads = "NONE"
)

// Defines values for ListUsageForServicePointsParamsIntervalReads.
const (
	ListUsageForServicePointsParamsIntervalReadsFULL  ListUsageForServicePointsParamsIntervalReads = "FULL"
	ListUsageForServicePointsParamsIntervalReadsMIN30 ListUsageForServicePointsParamsIntervalReads = "MIN_30"
	ListUsageForServicePointsParamsIntervalReadsNONE  ListUsageForServicePointsParamsIntervalReads = "NONE"
)

// Defines values for GetUsageForServicePointParamsIntervalReads.
const (
	FULL  GetUsageForServicePointParamsIntervalReads = "FULL"
	MIN30 GetUsageForServicePointParamsIntervalReads = "MIN_30"
	NONE  GetUsageForServicePointParamsIntervalReads = "NONE"
)

// Defines values for ListPlansParamsType.
const (
	ListPlansParamsTypeALL       ListPlansParamsType = "ALL"
	ListPlansParamsTypeMARKET    ListPlansParamsType = "MARKET"
	ListPlansParamsTypeREGULATED ListPlansParamsType = "REGULATED"
	ListPlansParamsTypeSTANDING  ListPlansParamsType = "STANDING"
)

// Defines values for ListPlansParamsFuelType.
const (
	ListPlansParamsFuelTypeALL         ListPlansParamsFuelType = "ALL"
	ListPlansParamsFuelTypeDUAL        ListPlansParamsFuelType = "DUAL"
	ListPlansParamsFuelTypeELECTRICITY ListPlansParamsFuelType = "ELECTRICITY"
	ListPlansParamsFuelTypeGAS         ListPlansParamsFuelType = "GAS"
)

// Defines values for ListPlansParamsEffective.
const (
	ListPlansParamsEffectiveALL     ListPlansParamsEffective = "ALL"
	ListPlansParamsEffectiveCURRENT ListPlansParamsEffective = "CURRENT"
	ListPlansParamsEffectiveFUTURE  ListPlansParamsEffective = "FUTURE"
)

// CommonPAFAddress Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). Required if addressUType is set to paf
type CommonPAFAddress struct {
	// BuildingName1 Building/Property name 1
	BuildingName1 *string `json:"buildingName1,omitempty"`

	// BuildingName2 Building/Property name 2
	BuildingName2 *string `json:"buildingName2,omitempty"`

	// Dpid Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
	Dpid *string `json:"dpid,omitempty"`

	// FlatUnitNumber Unit number (including suffix, if applicable)
	FlatUnitNumber *string `json:"flatUnitNumber,omitempty"`

	// FlatUnitType Type of flat or unit for the address
	FlatUnitType *string `json:"flatUnitType,omitempty"`

	// FloorLevelNumber Floor or level number (including alpha characters)
	FloorLevelNumber *string `json:"floorLevelNumber,omitempty"`

	// FloorLevelType Type of floor or level for the address
	FloorLevelType *string `json:"floorLevelType,omitempty"`

	// LocalityName Full name of locality
	LocalityName string `json:"localityName"`

	// LotNumber Allotment number for the address
	LotNumber *string `json:"lotNumber,omitempty"`

	// PostalDeliveryNumber Postal delivery number if the address is a postal delivery type
	PostalDeliveryNumber *int `json:"postalDeliveryNumber,omitempty"`

	// PostalDeliveryNumberPrefix Postal delivery number prefix related to the postal delivery number
	PostalDeliveryNumberPrefix *string `json:"postalDeliveryNumberPrefix,omitempty"`

	// PostalDeliveryNumberSuffix Postal delivery number suffix related to the postal delivery number
	PostalDeliveryNumberSuffix *string `json:"postalDeliveryNumberSuffix,omitempty"`

	// PostalDeliveryType Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
	PostalDeliveryType *string `json:"postalDeliveryType,omitempty"`

	// Postcode Postcode for the locality
	Postcode string `json:"postcode"`

	// State State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`

	// StreetName The name of the street
	StreetName *string `json:"streetName,omitempty"`

	// StreetSuffix The street type suffix. Valid enumeration defined by Australia Post PAF code file
	StreetSuffix *string `json:"streetSuffix,omitempty"`

	// StreetType The street type. Valid enumeration defined by Australia Post PAF code file
	StreetType *string `json:"streetType,omitempty"`

	// ThoroughfareNumber1 Thoroughfare number for a property (first number in a property ranged address)
	ThoroughfareNumber1 *int `json:"thoroughfareNumber1,omitempty"`

	// ThoroughfareNumber1Suffix Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
	ThoroughfareNumber1Suffix *string `json:"thoroughfareNumber1Suffix,omitempty"`

	// ThoroughfareNumber2 Second thoroughfare number (only used if the property has a ranged address eg 23-25)
	ThoroughfareNumber2 *int `json:"thoroughfareNumber2,omitempty"`

	// ThoroughfareNumber2Suffix Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
	ThoroughfareNumber2Suffix *string `json:"thoroughfareNumber2Suffix,omitempty"`
}

// CommonPhysicalAddress defines model for CommonPhysicalAddress.
type CommonPhysicalAddress struct {
	// AddressUType The type of address object present
	AddressUType CommonPhysicalAddressAddressUType `json:"addressUType"`

	// Paf Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). Required if addressUType is set to paf
	Paf *CommonPAFAddress `json:"paf,omitempty"`

	// Simple Required if addressUType is set to simple
	Simple *CommonSimpleAddress `json:"simple,omitempty"`
}

// CommonPhysicalAddressAddressUType The type of address object present
type CommonPhysicalAddressAddressUType string

// CommonSimpleAddress Required if addressUType is set to simple
type CommonSimpleAddress struct {
	// AddressLine1 First line of the standard address object
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Second line of the standard address object
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Third line of the standard address object
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City Name of the city or locality
	City string `json:"city"`

	// Country A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
	Country *string `json:"country,omitempty"`

	// MailingName Name of the individual or business formatted for inclusion in an address used for physical mail
	MailingName *string `json:"mailingName,omitempty"`

	// Postcode Mandatory for Australian addresses
	Postcode *string `json:"postcode,omitempty"`

	// State Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`
}

// EnergyAccountBaseV2 defines model for EnergyAccountBaseV2.
type EnergyAccountBaseV2 struct {
	// AccountId The ID of the account.  To be created in accordance with CDR ID permanence requirements
	AccountId string `json:"accountId"`

	// AccountNumber Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
	AccountNumber *string `json:"accountNumber,omitempty"`

	// CreationDate The date that the account was created or opened. Mandatory if openStatus is OPEN
	CreationDate *string `json:"creationDate,omitempty"`

	// DisplayName An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
	DisplayName *string `json:"displayName,omitempty"`

	// OpenStatus Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *EnergyAccountBaseV2OpenStatus `json:"openStatus,omitempty"`
}

// EnergyAccountBaseV2OpenStatus Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountBaseV2OpenStatus string

// EnergyAccountDetailResponseV2 defines model for EnergyAccountDetailResponseV2.
type EnergyAccountDetailResponseV2 struct {
	Data  EnergyAccountDetailV2   `json:"data"`
	Links Links                   `json:"links"`
	Meta  *map[string]interface{} `json:"meta,omitempty"`
}

// EnergyAccountDetailV2 defines model for EnergyAccountDetailV2.
type EnergyAccountDetailV2 struct {
	// AccountId The ID of the account.  To be created in accordance with CDR ID permanence requirements
	AccountId string `json:"accountId"`

	// AccountNumber Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
	AccountNumber *string `json:"accountNumber,omitempty"`

	// CreationDate The date that the account was created or opened. Mandatory if openStatus is OPEN
	CreationDate *string `json:"creationDate,omitempty"`

	// DisplayName An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
	DisplayName *string `json:"displayName,omitempty"`

	// OpenStatus Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *EnergyAccountDetailV2OpenStatus `json:"openStatus,omitempty"`

	// Plans The array of plans containing service points and associated plan details
	Plans []EnergyAccountDetailV2AllOfPlans `json:"plans"`
}

// EnergyAccountDetailV2OpenStatus Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountDetailV2OpenStatus string

// EnergyAccountDetailV2AllOf The array of plans containing service points and associated plan details
type EnergyAccountDetailV2AllOf struct {
	// Plans The array of plans containing service points and associated plan details
	Plans []EnergyAccountDetailV2AllOfPlans `json:"plans"`
}

// EnergyAccountDetailV2AllOfAuthorisedContacts defines model for EnergyAccountDetailV2_allOf_authorisedContacts.
type EnergyAccountDetailV2AllOfAuthorisedContacts struct {
	// FirstName For people with single names this field need not be present. The single name should be in the lastName field
	FirstName *string `json:"firstName,omitempty"`

	// LastName For people with single names the single name should be in this field
	LastName string `json:"lastName"`

	// MiddleNames Field is mandatory but array may be empty
	MiddleNames *[]string `json:"middleNames,omitempty"`

	// Prefix Also known as title or salutation. The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
	Prefix *string `json:"prefix,omitempty"`

	// Suffix Used for a trailing suffix to the name (e.g. Jr)
	Suffix *string `json:"suffix,omitempty"`
}

// EnergyAccountDetailV2AllOfPlanDetail Detail on the plan applicable to this account. Mandatory if openStatus is OPEN
type EnergyAccountDetailV2AllOfPlanDetail struct {
	ElectricityContract *EnergyPlanContract `json:"electricityContract,omitempty"`

	// FuelType The fuel types covered by the plan
	FuelType    EnergyAccountDetailV2AllOfPlanDetailFuelType `json:"fuelType"`
	GasContract *EnergyPlanContract                          `json:"gasContract,omitempty"`

	// IsContingentPlan Flag that indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up). Has no meaning if the plan has a fuelType of DUAL. If absent the value is assumed to be false
	IsContingentPlan *bool `json:"isContingentPlan,omitempty"`

	// MeteringCharges Charges for metering included in the plan
	MeteringCharges *[]EnergyPlanDetailAllOfMeteringCharges `json:"meteringCharges,omitempty"`
}

// EnergyAccountDetailV2AllOfPlanDetailFuelType The fuel types covered by the plan
type EnergyAccountDetailV2AllOfPlanDetailFuelType string

// EnergyAccountDetailV2AllOfPlans defines model for EnergyAccountDetailV2_allOf_plans.
type EnergyAccountDetailV2AllOfPlans struct {
	// AuthorisedContacts An array of additional contacts that are authorised to act on this account
	AuthorisedContacts *[]EnergyAccountDetailV2AllOfAuthorisedContacts `json:"authorisedContacts,omitempty"`

	// Nickname Optional display name for the plan provided by the customer to help differentiate multiple plans
	Nickname *string `json:"nickname,omitempty"`

	// PlanDetail Detail on the plan applicable to this account. Mandatory if openStatus is OPEN
	PlanDetail *EnergyAccountDetailV2AllOfPlanDetail `json:"planDetail,omitempty"`

	// PlanOverview Mandatory if openStatus is OPEN
	PlanOverview *EnergyAccountV2AllOfPlanOverview `json:"planOverview,omitempty"`

	// ServicePointIds An array of servicePointIds, representing NMIs, that this account is linked to
	ServicePointIds []string `json:"servicePointIds"`
}

// EnergyAccountListResponseV2 defines model for EnergyAccountListResponseV2.
type EnergyAccountListResponseV2 struct {
	Data  EnergyAccountListResponseV2Data `json:"data"`
	Links LinksPaginated                  `json:"links"`
	Meta  MetaPaginated                   `json:"meta"`
}

// EnergyAccountListResponseV2Data defines model for EnergyAccountListResponseV2_data.
type EnergyAccountListResponseV2Data struct {
	// Accounts Array of accounts
	Accounts []EnergyAccountV2 `json:"accounts"`
}

// EnergyAccountV2 defines model for EnergyAccountV2.
type EnergyAccountV2 struct {
	// AccountId The ID of the account.  To be created in accordance with CDR ID permanence requirements
	AccountId string `json:"accountId"`

	// AccountNumber Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
	AccountNumber *string `json:"accountNumber,omitempty"`

	// CreationDate The date that the account was created or opened. Mandatory if openStatus is OPEN
	CreationDate *string `json:"creationDate,omitempty"`

	// DisplayName An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
	DisplayName *string `json:"displayName,omitempty"`

	// OpenStatus Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *EnergyAccountV2OpenStatus `json:"openStatus,omitempty"`

	// Plans The array of plans containing service points and associated plan details
	Plans []EnergyAccountV2AllOfPlans `json:"plans"`
}

// EnergyAccountV2OpenStatus Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountV2OpenStatus string

// EnergyAccountV2AllOf The array of plans containing service points and associated plan details
type EnergyAccountV2AllOf struct {
	// Plans The array of plans containing service points and associated plan details
	Plans []EnergyAccountV2AllOfPlans `json:"plans"`
}

// EnergyAccountV2AllOfPlanOverview Mandatory if openStatus is OPEN
type EnergyAccountV2AllOfPlanOverview struct {
	// DisplayName The name of the plan if one exists
	DisplayName *string `json:"displayName,omitempty"`

	// EndDate The end date of the applicability of this plan
	EndDate *string `json:"endDate,omitempty"`

	// StartDate The start date of the applicability of this plan
	StartDate string `json:"startDate"`
}

// EnergyAccountV2AllOfPlans defines model for EnergyAccountV2_allOf_plans.
type EnergyAccountV2AllOfPlans struct {
	// Nickname Optional display name for the plan provided by the customer to help differentiate multiple plans
	Nickname *string `json:"nickname,omitempty"`

	// PlanOverview Mandatory if openStatus is OPEN
	PlanOverview *EnergyAccountV2AllOfPlanOverview `json:"planOverview,omitempty"`

	// ServicePointIds An array of servicePointIds, representing NMIs, that this plan is linked to.  If there are no service points allocated to this plan then an empty array would be expected
	ServicePointIds []string `json:"servicePointIds"`
}

// EnergyBalanceListResponse defines model for EnergyBalanceListResponse.
type EnergyBalanceListResponse struct {
	Data  EnergyBalanceListResponseData `json:"data"`
	Links LinksPaginated                `json:"links"`
	Meta  MetaPaginated                 `json:"meta"`
}

// EnergyBalanceListResponseData defines model for EnergyBalanceListResponse_data.
type EnergyBalanceListResponseData struct {
	// Balances Array of account balances
	Balances []EnergyBalanceListResponseDataBalances `json:"balances"`
}

// EnergyBalanceListResponseDataBalances defines model for EnergyBalanceListResponse_data_balances.
type EnergyBalanceListResponseDataBalances struct {
	// AccountId The ID of the account
	AccountId string `json:"accountId"`

	// Balance The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
	Balance string `json:"balance"`
}

// EnergyBalanceResponse defines model for EnergyBalanceResponse.
type EnergyBalanceResponse struct {
	Data  EnergyBalanceResponseData `json:"data"`
	Links Links                     `json:"links"`
	Meta  *map[string]interface{}   `json:"meta,omitempty"`
}

// EnergyBalanceResponseData defines model for EnergyBalanceResponse_data.
type EnergyBalanceResponseData struct {
	// Balance The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
	Balance string `json:"balance"`
}

// EnergyBillingDemandTransaction defines model for EnergyBillingDemandTransaction.
type EnergyBillingDemandTransaction struct {
	// Adjustments Optional array of adjustments arising for this transaction
	Adjustments *[]EnergyBillingUsageTransactionAdjustments `json:"adjustments,omitempty"`

	// Amount The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
	Amount string `json:"amount"`

	// CalculationFactors Additional calculation factors that inform the transaction
	CalculationFactors *[]EnergyBillingUsageTransactionCalculationFactors `json:"calculationFactors,omitempty"`

	// Description Optional description of the transaction that can be used for display purposes
	Description *string `json:"description,omitempty"`

	// EndDate Date and time when the demand period ends
	EndDate string `json:"endDate"`

	// InvoiceNumber The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// IsEstimate Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
	IsEstimate *bool `json:"isEstimate,omitempty"`

	// Rate The rate for the demand charge in kVA.  A negative value indicates power generated
	Rate float32 `json:"rate"`

	// ServicePointId The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// StartDate Date and time when the demand period starts
	StartDate string `json:"startDate"`

	// TimeOfUseType The time of use type that the transaction applies to
	TimeOfUseType EnergyBillingDemandTransactionTimeOfUseType `json:"timeOfUseType"`
}

// EnergyBillingDemandTransactionTimeOfUseType The time of use type that the transaction applies to
type EnergyBillingDemandTransactionTimeOfUseType string

// EnergyBillingListResponse defines model for EnergyBillingListResponse.
type EnergyBillingListResponse struct {
	Data  EnergyBillingListResponseData `json:"data"`
	Links LinksPaginated                `json:"links"`
	Meta  MetaPaginated                 `json:"meta"`
}

// EnergyBillingListResponseData defines model for EnergyBillingListResponse_data.
type EnergyBillingListResponseData struct {
	// Transactions Array of transactions sorted by date and time in descending order
	Transactions []EnergyBillingTransaction `json:"transactions"`
}

// EnergyBillingOnceOffTransaction defines model for EnergyBillingOnceOffTransaction.
type EnergyBillingOnceOffTransaction struct {
	// Amount The amount of the charge or credit.  A positive value indicates a charge and a negative value indicates a credit
	Amount string `json:"amount"`

	// Description A free text description of the item
	Description string `json:"description"`

	// InvoiceNumber The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// ServicePointId The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`
}

// EnergyBillingOtherTransaction defines model for EnergyBillingOtherTransaction.
type EnergyBillingOtherTransaction struct {
	// Adjustments Optional array of adjustments arising for this transaction
	Adjustments *[]EnergyBillingUsageTransactionAdjustments `json:"adjustments,omitempty"`

	// Amount The amount of the charge
	Amount string `json:"amount"`

	// CalculationFactors Additional calculation factors that inform the transaction
	CalculationFactors *[]EnergyBillingUsageTransactionCalculationFactors `json:"calculationFactors,omitempty"`

	// Description A free text description of the item
	Description string `json:"description"`

	// EndDate Optional end date for the application of the charge
	EndDate *string `json:"endDate,omitempty"`

	// InvoiceNumber The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// ServicePointId The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// StartDate Optional start date for the application of the charge
	StartDate *string `json:"startDate,omitempty"`

	// Type Type of charge. Assumed to be other if absent
	Type *EnergyBillingOtherTransactionType `json:"type,omitempty"`
}

// EnergyBillingOtherTransactionType Type of charge. Assumed to be other if absent
type EnergyBillingOtherTransactionType string

// EnergyBillingPaymentTransaction defines model for EnergyBillingPaymentTransaction.
type EnergyBillingPaymentTransaction struct {
	// Amount The amount paid
	Amount string `json:"amount"`

	// Method The method of payment
	Method EnergyBillingPaymentTransactionMethod `json:"method"`
}

// EnergyBillingPaymentTransactionMethod The method of payment
type EnergyBillingPaymentTransactionMethod string

// EnergyBillingTransaction defines model for EnergyBillingTransaction.
type EnergyBillingTransaction struct {
	// AccountId The ID of the account for which transaction applies
	AccountId string                          `json:"accountId"`
	Demand    *EnergyBillingDemandTransaction `json:"demand,omitempty"`

	// ExecutionDateTime The date and time that the transaction occurred
	ExecutionDateTime string `json:"executionDateTime"`

	// Gst The GST incurred in the transaction.  Should not be included for credits or payments.  If absent zero is assumed
	Gst          *string                          `json:"gst,omitempty"`
	OnceOff      *EnergyBillingOnceOffTransaction `json:"onceOff,omitempty"`
	OtherCharges *EnergyBillingOtherTransaction   `json:"otherCharges,omitempty"`
	Payment      *EnergyBillingPaymentTransaction `json:"payment,omitempty"`

	// TransactionUType Indicator of the type of transaction object present in this record
	TransactionUType EnergyBillingTransactionTransactionUType `json:"transactionUType"`
	Usage            *EnergyBillingUsageTransaction           `json:"usage,omitempty"`
}

// EnergyBillingTransactionTransactionUType Indicator of the type of transaction object present in this record
type EnergyBillingTransactionTransactionUType string

// EnergyBillingUsageTransaction defines model for EnergyBillingUsageTransaction.
type EnergyBillingUsageTransaction struct {
	// Adjustments Optional array of adjustments arising for this transaction
	Adjustments *[]EnergyBillingUsageTransactionAdjustments `json:"adjustments,omitempty"`

	// Amount The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
	Amount string `json:"amount"`

	// CalculationFactors Additional calculation factors that inform the transaction
	CalculationFactors *[]EnergyBillingUsageTransactionCalculationFactors `json:"calculationFactors,omitempty"`

	// Description Optional description of the transaction that can be used for display purposes
	Description *string `json:"description,omitempty"`

	// EndDate Date and time when the usage period ends
	EndDate string `json:"endDate"`

	// InvoiceNumber The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// IsEstimate Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
	IsEstimate *bool `json:"isEstimate,omitempty"`

	// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
	MeasureUnit *EnergyBillingUsageTransactionMeasureUnit `json:"measureUnit,omitempty"`

	// ServicePointId The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// StartDate Date and time when the usage period starts
	StartDate string `json:"startDate"`

	// TimeOfUseType The time of use type that the transaction applies to
	TimeOfUseType EnergyBillingUsageTransactionTimeOfUseType `json:"timeOfUseType"`

	// Usage The usage for the period in measure unit.  A negative value indicates power generated
	Usage float32 `json:"usage"`
}

// EnergyBillingUsageTransactionMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyBillingUsageTransactionMeasureUnit string

// EnergyBillingUsageTransactionTimeOfUseType The time of use type that the transaction applies to
type EnergyBillingUsageTransactionTimeOfUseType string

// EnergyBillingUsageTransactionAdjustments defines model for EnergyBillingUsageTransaction_adjustments.
type EnergyBillingUsageTransactionAdjustments struct {
	// Amount The amount of the adjustment
	Amount string `json:"amount"`

	// Description A free text description of the adjustment
	Description string `json:"description"`
}

// EnergyBillingUsageTransactionCalculationFactors defines model for EnergyBillingUsageTransaction_calculationFactors.
type EnergyBillingUsageTransactionCalculationFactors struct {
	// Type The type of the calculation factor
	Type EnergyBillingUsageTransactionCalculationFactorsType `json:"type"`

	// Value The value of the calculation factor
	Value float32 `json:"value"`
}

// EnergyBillingUsageTransactionCalculationFactorsType The type of the calculation factor
type EnergyBillingUsageTransactionCalculationFactorsType string

// EnergyConcession defines model for EnergyConcession.
type EnergyConcession struct {
	// AdditionalInfo Display text providing more information on the concession. Mandatory if type is VARIABLE
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Optional link to additional information regarding the concession
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// Amount Conditional attribute for the amount of discount for the concession- required if type is FIXED_AMOUNT
	Amount *string `json:"amount,omitempty"`

	// AppliedTo Array of ENUM's to specify what the concession applies to. Multiple ENUM values can be provided. If absent, USAGE is assumed
	AppliedTo *[]EnergyConcessionAppliedTo `json:"appliedTo,omitempty"`

	// DiscountFrequency Conditional attribute for frequency at which a concession is applied. Required if type is FIXED_AMOUNT or FIXED_PERCENTAGE. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	DiscountFrequency *string `json:"discountFrequency,omitempty"`

	// DisplayName The display name of the concession
	DisplayName string `json:"displayName"`

	// EndDate Optional end date for the application of the concession
	EndDate *string `json:"endDate,omitempty"`

	// Percentage Conditional attribute for the percentage of discount of concession - required if type is FIXED_PERCENTAGE
	Percentage *string `json:"percentage,omitempty"`

	// StartDate Optional start date for the application of the concession
	StartDate *string `json:"startDate,omitempty"`

	// Type Indicator of the method of concession calculation
	Type EnergyConcessionType `json:"type"`
}

// EnergyConcessionAppliedTo defines model for EnergyConcession.AppliedTo.
type EnergyConcessionAppliedTo string

// EnergyConcessionType Indicator of the method of concession calculation
type EnergyConcessionType string

// EnergyConcessionsResponse defines model for EnergyConcessionsResponse.
type EnergyConcessionsResponse struct {
	Data  EnergyConcessionsResponseData `json:"data"`
	Links Links                         `json:"links"`
	Meta  *map[string]interface{}       `json:"meta,omitempty"`
}

// EnergyConcessionsResponseData defines model for EnergyConcessionsResponse_data.
type EnergyConcessionsResponseData struct {
	// Concessions Array may be empty if no concessions exist
	Concessions []EnergyConcession `json:"concessions"`
}

// EnergyDerDetailResponse defines model for EnergyDerDetailResponse.
type EnergyDerDetailResponse struct {
	Data  EnergyDerRecord         `json:"data"`
	Links Links                   `json:"links"`
	Meta  *map[string]interface{} `json:"meta,omitempty"`
}

// EnergyDerListResponse defines model for EnergyDerListResponse.
type EnergyDerListResponse struct {
	Data  EnergyDerListResponseData `json:"data"`
	Links LinksPaginated            `json:"links"`
	Meta  MetaPaginated             `json:"meta"`
}

// EnergyDerListResponseData defines model for EnergyDerListResponse_data.
type EnergyDerListResponseData struct {
	// DerRecords Array of meter reads
	DerRecords []EnergyDerRecord `json:"derRecords"`
}

// EnergyDerRecord defines model for EnergyDerRecord.
type EnergyDerRecord struct {
	AcConnections []EnergyDerRecordAcConnections `json:"acConnections"`

	// ApprovedCapacity Approved small generating unit capacity as agreed with NSP in the connection agreement, expressed in kVA. Value of 0 indicates no DER record exists for the given servicePointId
	ApprovedCapacity float32 `json:"approvedCapacity"`

	// AvailablePhasesCount The number of phases available for the installation of DER. Acceptable values are 0, 1, 2 or 3. Value of 0 indicates no DER record exists for the given servicePointId
	AvailablePhasesCount int `json:"availablePhasesCount"`

	// HasCentralProtectionControl For DER installations where NSPs specify the need for additional forms of protection above those inbuilt in an inverter.  If absent then assumed to be false
	HasCentralProtectionControl *bool `json:"hasCentralProtectionControl,omitempty"`

	// InstalledPhasesCount The number of phases that DER is connected to. Acceptable values are 0, 1, 2 or 3. Value of 0 indicates no DER record exists for the given servicePointId
	InstalledPhasesCount int `json:"installedPhasesCount"`

	// IslandableInstallation For identification of small generating units designed with the ability to operate in an islanded mode
	IslandableInstallation bool `json:"islandableInstallation"`

	// ProtectionMode Required only when the hasCentralProtectionAndControl flag is set to true.  One or more of the object fields will be provided to describe the protection modes in place
	ProtectionMode *EnergyDerRecordProtectionMode `json:"protectionMode,omitempty"`

	// ServicePointId Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`
}

// EnergyDerRecordAcConnections defines model for EnergyDerRecord_acConnections.
type EnergyDerRecordAcConnections struct {
	// CommissioningDate The date that the DER installation is commissioned
	CommissioningDate string `json:"commissioningDate"`

	// ConnectionIdentifier AC Connection ID as defined in the DER register.  Does not align with CDR ID permanence standards
	ConnectionIdentifier float32 `json:"connectionIdentifier"`

	// Count Number of AC Connections in the group. For the suite of AC Connections to be considered as a group, all of the AC Connections included must have the same attributes
	Count      int                         `json:"count"`
	DerDevices []EnergyDerRecordDerDevices `json:"derDevices"`

	// EquipmentType Indicates whether the DER device is connected via an inverter (and what category of inverter it is) or not (e.g. rotating machine). If absent, assume equipment type to be “OTHER”.
	EquipmentType *EnergyDerRecordAcConnectionsEquipmentType `json:"equipmentType,omitempty"`

	// InverterDeviceCapacity The rated AC output power that is listed in the product specified by the manufacturer. Mandatory if equipmentType is INVERTER. Default is 0 if value not known
	InverterDeviceCapacity *float32 `json:"inverterDeviceCapacity,omitempty"`

	// InverterModelNumber The inverter model number. Mandatory if equipmentType is INVERTER
	InverterModelNumber *string `json:"inverterModelNumber,omitempty"`

	// InverterSeries The inverter series. Mandatory if equipmentType is INVERTER
	InverterSeries *string `json:"inverterSeries,omitempty"`

	// ManufacturerName The name of the inverter manufacturer. Mandatory if equipmentType is INVERTER
	ManufacturerName *string `json:"manufacturerName,omitempty"`

	// Status Code used to indicate the status of the Inverter. This will be used to identify if an inverter is active or inactive or decommissioned
	Status EnergyDerRecordAcConnectionsStatus `json:"status"`
}

// EnergyDerRecordAcConnectionsEquipmentType Indicates whether the DER device is connected via an inverter (and what category of inverter it is) or not (e.g. rotating machine). If absent, assume equipment type to be “OTHER”.
type EnergyDerRecordAcConnectionsEquipmentType string

// EnergyDerRecordAcConnectionsStatus Code used to indicate the status of the Inverter. This will be used to identify if an inverter is active or inactive or decommissioned
type EnergyDerRecordAcConnectionsStatus string

// EnergyDerRecordDerDevices defines model for EnergyDerRecord_derDevices.
type EnergyDerRecordDerDevices struct {
	// Count Number of devices in the group of DER devices
	Count int `json:"count"`

	// DeviceIdentifier Unique identifier for a single DER device or a group of DER devices with the same attributes. Does not align with CDR ID permanence standards
	DeviceIdentifier float32 `json:"deviceIdentifier"`

	// Manufacturer The name of the device manufacturer. If absent then assumed to be “unknown”
	Manufacturer *string `json:"manufacturer,omitempty"`

	// ModelNumber The model number of the device. If absent then assumed to be “unknown”
	ModelNumber *string `json:"modelNumber,omitempty"`

	// NominalRatedCapacity Maximum output in kVA that is listed in the product specification by the manufacturer. This refers to the capacity of each unit within the device group. Default is 0 if value not known
	NominalRatedCapacity float32 `json:"nominalRatedCapacity"`

	// NominalStorageCapacity Maximum storage capacity in kVAh. This refers to the capacity of each storage module within the device group. Mandatory if type is equal to “STORAGE”. Default is 0 if value not known
	NominalStorageCapacity *float32 `json:"nominalStorageCapacity,omitempty"`

	// Status Code used to indicate the status of the device. This will be used to identify if an inverter is active or inactive or decommissioned
	Status *EnergyDerRecordDerDevicesStatus `json:"status,omitempty"`

	// Subtype Used to indicate the primary technology used in the DER device. This field is also used to record for example the battery chemistry, or the type of PV panel. It is also used to record if a battery is contained in an electric vehicle connected in a vehicle-to-grid arrangement. If absent then assumed to be “other”
	Subtype *string `json:"subtype,omitempty"`

	// Type Used to indicate the primary technology used in the DER device
	Type EnergyDerRecordDerDevicesType `json:"type"`
}

// EnergyDerRecordDerDevicesStatus Code used to indicate the status of the device. This will be used to identify if an inverter is active or inactive or decommissioned
type EnergyDerRecordDerDevicesStatus string

// EnergyDerRecordDerDevicesType Used to indicate the primary technology used in the DER device
type EnergyDerRecordDerDevicesType string

// EnergyDerRecordProtectionMode Required only when the hasCentralProtectionAndControl flag is set to true.  One or more of the object fields will be provided to describe the protection modes in place
type EnergyDerRecordProtectionMode struct {
	// ExportLimitKva Maximum amount of power (kVA) that may be exported from a connection point to the grid, as monitored by a control / relay function. An absent value indicates no limit
	ExportLimitKva *float32 `json:"exportLimitKva,omitempty"`

	// FrequencyRateOfChange Rate of change of frequency trip point (Hz/s).
	FrequencyRateOfChange *float32 `json:"frequencyRateOfChange,omitempty"`

	// InterTripScheme Description of the form of inter-trip (e.g. 'from local substation').
	InterTripScheme *string `json:"interTripScheme,omitempty"`

	// NeutralVoltageDisplacement Trip voltage.
	NeutralVoltageDisplacement *float32 `json:"neutralVoltageDisplacement,omitempty"`

	// OverFrequencyProtection Protective function limit in Hz.
	OverFrequencyProtection *float32 `json:"overFrequencyProtection,omitempty"`

	// OverFrequencyProtectionDelay Trip delay time in seconds.
	OverFrequencyProtectionDelay *float32 `json:"overFrequencyProtectionDelay,omitempty"`

	// OverVoltageProtection Protective function limit in V.
	OverVoltageProtection *float32 `json:"overVoltageProtection,omitempty"`

	// OverVoltageProtectionDelay Trip delay time in seconds.
	OverVoltageProtectionDelay *float32 `json:"overVoltageProtectionDelay,omitempty"`

	// SustainedOverVoltage Sustained over voltage.
	SustainedOverVoltage *float32 `json:"sustainedOverVoltage,omitempty"`

	// SustainedOverVoltageDelay Sustained Over voltage protection delay in seconds.
	SustainedOverVoltageDelay *float32 `json:"sustainedOverVoltageDelay,omitempty"`

	// UnderFrequencyProtection Protective function limit in Hz.
	UnderFrequencyProtection *float32 `json:"underFrequencyProtection,omitempty"`

	// UnderFrequencyProtectionDelay Trip delay time in seconds.
	UnderFrequencyProtectionDelay *float32 `json:"underFrequencyProtectionDelay,omitempty"`

	// UnderVoltageProtection Protective function limit in V.
	UnderVoltageProtection *float32 `json:"underVoltageProtection,omitempty"`

	// UnderVoltageProtectionDelay Trip delay time in seconds.
	UnderVoltageProtectionDelay *float32 `json:"underVoltageProtectionDelay,omitempty"`

	// VoltageVectorShift Trip angle in degrees.
	VoltageVectorShift *float32 `json:"voltageVectorShift,omitempty"`
}

// EnergyInvoice defines model for EnergyInvoice.
type EnergyInvoice struct {
	// AccountCharges Object contains account level charges and credits related to electricity usage
	AccountCharges *EnergyInvoiceAccountCharges `json:"accountCharges,omitempty"`

	// AccountId The ID of the account for which the invoice was issued
	AccountId string `json:"accountId"`

	// BalanceAtIssue The account balance at the time the invoice was issued
	BalanceAtIssue string `json:"balanceAtIssue"`

	// DueDate The date that the invoice is due to be paid
	DueDate     *string                               `json:"dueDate,omitempty"`
	Electricity *EnergyInvoiceElectricityUsageCharges `json:"electricity,omitempty"`
	Gas         *EnergyInvoiceGasUsageCharges         `json:"gas,omitempty"`

	// GstAmount The total GST amount for this invoice.  If absent then zero is assumed
	GstAmount *string `json:"gstAmount,omitempty"`

	// InvoiceAmount The net amount due for this invoice regardless of previous balance
	InvoiceAmount *string `json:"invoiceAmount,omitempty"`

	// InvoiceNumber The number assigned to this invoice by the energy Retailer
	InvoiceNumber string `json:"invoiceNumber"`

	// IssueDate The date that the invoice was actually issued (as opposed to generated or calculated)
	IssueDate string `json:"issueDate"`

	// PayOnTimeDiscount A discount for on time payment
	PayOnTimeDiscount *EnergyInvoicePayOnTimeDiscount `json:"payOnTimeDiscount,omitempty"`

	// PaymentStatus Indicator of the payment status for the invoice
	PaymentStatus EnergyInvoicePaymentStatus `json:"paymentStatus"`

	// Period Object containing the start and end date for the period covered by the invoice.  Mandatory if any usage or demand based charges are included in the invoice
	Period *EnergyInvoicePeriod `json:"period,omitempty"`

	// ServicePoints Array of service point IDs to which this invoice applies. May be empty if the invoice contains no electricity usage related charges
	ServicePoints []string `json:"servicePoints"`
}

// EnergyInvoicePaymentStatus Indicator of the payment status for the invoice
type EnergyInvoicePaymentStatus string

// EnergyInvoiceAccountCharges Object contains account level charges and credits related to electricity usage
type EnergyInvoiceAccountCharges struct {
	// TotalCharges The aggregate total of account level charges for the period covered by the invoice
	TotalCharges string `json:"totalCharges"`

	// TotalDiscounts The aggregate total of account level discounts or credits for the period covered by the invoice
	TotalDiscounts string `json:"totalDiscounts"`

	// TotalGst The total GST for all account level charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`
}

// EnergyInvoiceElectricityUsageCharges defines model for EnergyInvoiceElectricityUsageCharges.
type EnergyInvoiceElectricityUsageCharges struct {
	// OtherCharges Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
	OtherCharges *[]EnergyInvoiceGasUsageChargesOtherCharges `json:"otherCharges,omitempty"`

	// TotalGenerationCredits The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
	TotalGenerationCredits string `json:"totalGenerationCredits"`

	// TotalGst The total GST for all electricity usage charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`

	// TotalOnceOffCharges The aggregate total of any once off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffCharges string `json:"totalOnceOffCharges"`

	// TotalOnceOffDiscounts The aggregate total of any once off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffDiscounts string `json:"totalOnceOffDiscounts"`

	// TotalUsageCharges The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
	TotalUsageCharges string `json:"totalUsageCharges"`
}

// EnergyInvoiceGasUsageCharges defines model for EnergyInvoiceGasUsageCharges.
type EnergyInvoiceGasUsageCharges struct {
	// OtherCharges Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
	OtherCharges *[]EnergyInvoiceGasUsageChargesOtherCharges `json:"otherCharges,omitempty"`

	// TotalGenerationCredits The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
	TotalGenerationCredits string `json:"totalGenerationCredits"`

	// TotalGst The total GST for all electricity usage charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`

	// TotalOnceOffCharges The aggregate total of any once off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffCharges string `json:"totalOnceOffCharges"`

	// TotalOnceOffDiscounts The aggregate total of any once off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffDiscounts string `json:"totalOnceOffDiscounts"`

	// TotalUsageCharges The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
	TotalUsageCharges string `json:"totalUsageCharges"`
}

// EnergyInvoiceGasUsageChargesOtherCharges defines model for EnergyInvoiceGasUsageCharges_otherCharges.
type EnergyInvoiceGasUsageChargesOtherCharges struct {
	// Amount The aggregate total of charges for this item (exclusive of GST)
	Amount string `json:"amount"`

	// Description A free text description of the type of charge
	Description string `json:"description"`

	// Type Type of charge. Assumed to be other if absent
	Type *EnergyInvoiceGasUsageChargesOtherChargesType `json:"type,omitempty"`
}

// EnergyInvoiceGasUsageChargesOtherChargesType Type of charge. Assumed to be other if absent
type EnergyInvoiceGasUsageChargesOtherChargesType string

// EnergyInvoiceListResponse defines model for EnergyInvoiceListResponse.
type EnergyInvoiceListResponse struct {
	Data  EnergyInvoiceListResponseData `json:"data"`
	Links LinksPaginated                `json:"links"`
	Meta  MetaPaginated                 `json:"meta"`
}

// EnergyInvoiceListResponseData defines model for EnergyInvoiceListResponse_data.
type EnergyInvoiceListResponseData struct {
	// Invoices Array of invoices sorted by issue date in descending order
	Invoices []EnergyInvoice `json:"invoices"`
}

// EnergyInvoicePayOnTimeDiscount A discount for on time payment
type EnergyInvoicePayOnTimeDiscount struct {
	// Date The date by which the invoice must be paid to receive the pay on time discount
	Date string `json:"date"`

	// DiscountAmount The amount that will be discounted if the invoice is paid by the date specified
	DiscountAmount string `json:"discountAmount"`

	// GstAmount The GST amount that will be discounted if the invoice is paid by the date specified.  If absent then zero is assumed
	GstAmount *string `json:"gstAmount,omitempty"`
}

// EnergyInvoicePeriod Object containing the start and end date for the period covered by the invoice.  Mandatory if any usage or demand based charges are included in the invoice
type EnergyInvoicePeriod struct {
	// EndDate The end date of the period covered by this invoice
	EndDate string `json:"endDate"`

	// StartDate The start date of the period covered by this invoice
	StartDate string `json:"startDate"`
}

// EnergyPaymentSchedule defines model for EnergyPaymentSchedule.
type EnergyPaymentSchedule struct {
	// Amount Optional payment amount indicating that a constant payment amount is scheduled to be paid (used in bill smooting scenarios)
	Amount *string `json:"amount,omitempty"`

	// CardDebit Represents a regular credit card payment schedule. Mandatory if paymentScheduleUType is set to cardDebit
	CardDebit *EnergyPaymentScheduleCardDebit `json:"cardDebit,omitempty"`

	// DigitalWallet Represents a regular payment from a digital wallet. Mandatory if paymentScheduleUType is set to digitalWallet
	DigitalWallet *EnergyPaymentScheduleDigitalWallet `json:"digitalWallet,omitempty"`

	// DirectDebit Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
	DirectDebit *EnergyPaymentScheduleDirectDebit `json:"directDebit,omitempty"`

	// ManualPayment Represents a manual payment schedule where the customer pays in response to a delivered statement. Mandatory if paymentScheduleUType is set to manualPayment
	ManualPayment *EnergyPaymentScheduleManualPayment `json:"manualPayment,omitempty"`

	// PaymentScheduleUType The type of object present in this response
	PaymentScheduleUType EnergyPaymentSchedulePaymentScheduleUType `json:"paymentScheduleUType"`
}

// EnergyPaymentSchedulePaymentScheduleUType The type of object present in this response
type EnergyPaymentSchedulePaymentScheduleUType string

// EnergyPaymentScheduleResponse defines model for EnergyPaymentScheduleResponse.
type EnergyPaymentScheduleResponse struct {
	Data  EnergyPaymentScheduleResponseData `json:"data"`
	Links Links                             `json:"links"`
	Meta  *map[string]interface{}           `json:"meta,omitempty"`
}

// EnergyPaymentScheduleResponseData defines model for EnergyPaymentScheduleResponse_data.
type EnergyPaymentScheduleResponseData struct {
	// PaymentSchedules Array may be empty if no payment schedule exist
	PaymentSchedules []EnergyPaymentSchedule `json:"paymentSchedules"`
}

// EnergyPaymentScheduleCardDebit Represents a regular credit card payment schedule. Mandatory if paymentScheduleUType is set to cardDebit
type EnergyPaymentScheduleCardDebit struct {
	// CalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
	CalculationType EnergyPaymentScheduleCardDebitCalculationType `json:"calculationType"`

	// CardScheme The type of credit card held on file
	CardScheme EnergyPaymentScheduleCardDebitCardScheme `json:"cardScheme"`

	// PaymentFrequency The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	PaymentFrequency string `json:"paymentFrequency"`
}

// EnergyPaymentScheduleCardDebitCalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleCardDebitCalculationType string

// EnergyPaymentScheduleCardDebitCardScheme The type of credit card held on file
type EnergyPaymentScheduleCardDebitCardScheme string

// EnergyPaymentScheduleDigitalWallet Represents a regular payment from a digital wallet. Mandatory if paymentScheduleUType is set to digitalWallet
type EnergyPaymentScheduleDigitalWallet struct {
	// CalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
	CalculationType EnergyPaymentScheduleDigitalWalletCalculationType `json:"calculationType"`

	// Identifier The identifier of the digital wallet (dependent on type)
	Identifier string `json:"identifier"`

	// Name The name assigned to the digital wallet by the owner of the wallet, else the display name provided by the digital wallet provider
	Name string `json:"name"`

	// PaymentFrequency The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	PaymentFrequency string `json:"paymentFrequency"`

	// Provider The provider of the digital wallet
	Provider EnergyPaymentScheduleDigitalWalletProvider `json:"provider"`

	// Type The type of the digital wallet identifier
	Type EnergyPaymentScheduleDigitalWalletType `json:"type"`
}

// EnergyPaymentScheduleDigitalWalletCalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleDigitalWalletCalculationType string

// EnergyPaymentScheduleDigitalWalletProvider The provider of the digital wallet
type EnergyPaymentScheduleDigitalWalletProvider string

// EnergyPaymentScheduleDigitalWalletType The type of the digital wallet identifier
type EnergyPaymentScheduleDigitalWalletType string

// EnergyPaymentScheduleDirectDebit Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
type EnergyPaymentScheduleDirectDebit struct {
	// AccountNumber The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
	AccountNumber *string `json:"accountNumber,omitempty"`

	// Bsb The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
	Bsb *string `json:"bsb,omitempty"`

	// CalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
	CalculationType EnergyPaymentScheduleDirectDebitCalculationType `json:"calculationType"`

	// IsTokenised Flag indicating that the account details are tokenised and cannot be shared.  False if absent
	IsTokenised *bool `json:"isTokenised,omitempty"`

	// PaymentFrequency The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	PaymentFrequency string `json:"paymentFrequency"`
}

// EnergyPaymentScheduleDirectDebitCalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleDirectDebitCalculationType string

// EnergyPaymentScheduleManualPayment Represents a manual payment schedule where the customer pays in response to a delivered statement. Mandatory if paymentScheduleUType is set to manualPayment
type EnergyPaymentScheduleManualPayment struct {
	// BillFrequency The frequency with which a bill will be issued.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	BillFrequency string `json:"billFrequency"`
}

// EnergyPlan defines model for EnergyPlan.
type EnergyPlan struct {
	// AdditionalInformation Object that contains links to additional information on specific topics
	AdditionalInformation *EnergyPlanAdditionalInformation `json:"additionalInformation,omitempty"`

	// ApplicationUri A link to an application web page where this plan can be applied for
	ApplicationUri *string `json:"applicationUri,omitempty"`

	// Brand The ID of the brand under which this plan is offered
	Brand string `json:"brand"`

	// BrandName The display name of the brand under which this plan is offered
	BrandName string `json:"brandName"`

	// CustomerType The type of customer that the plan is offered to.  If absent then the plan is available to all customers
	CustomerType *EnergyPlanCustomerType `json:"customerType,omitempty"`

	// Description A description of the plan
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the plan
	DisplayName *string `json:"displayName,omitempty"`

	// EffectiveFrom The date and time from which this plan is effective (ie. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
	EffectiveTo *string `json:"effectiveTo,omitempty"`

	// FuelType The fuel types covered by the plan
	FuelType EnergyPlanFuelType `json:"fuelType"`

	// Geography Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
	Geography *EnergyPlanGeography `json:"geography,omitempty"`

	// LastUpdated The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
	LastUpdated string `json:"lastUpdated"`

	// PlanId The ID of the specific plan
	PlanId string `json:"planId"`

	// Type The type of the plan
	Type EnergyPlanType `json:"type"`
}

// EnergyPlanCustomerType The type of customer that the plan is offered to.  If absent then the plan is available to all customers
type EnergyPlanCustomerType string

// EnergyPlanFuelType The fuel types covered by the plan
type EnergyPlanFuelType string

// EnergyPlanType The type of the plan
type EnergyPlanType string

// EnergyPlanContract defines model for EnergyPlanContract.
type EnergyPlanContract struct {
	// AdditionalFeeInformation Free text field containing additional information of the fees for this contract
	AdditionalFeeInformation *string `json:"additionalFeeInformation,omitempty"`

	// ControlledLoad Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
	ControlledLoad *[]struct {
		// DisplayName A display name for the controlled load
		DisplayName string `json:"displayName"`

		// EndDate Optional end date of the application of the controlled load rate
		EndDate *string `json:"endDate,omitempty"`

		// RateBlockUType Specifies the type of controlloed load rate
		RateBlockUType EnergyPlanContractControlledLoadRateBlockUType `json:"rateBlockUType"`

		// SingleRate Object representing a single controlled load rate.  Required if rateBlockUType is singleRate
		SingleRate *struct {
			// DailySupplyCharge The daily supply charge (exclusive of GST) for this controlled load tier
			DailySupplyCharge *string `json:"dailySupplyCharge,omitempty"`

			// Description Description of the controlled load rate
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the controlled load rate
			DisplayName string `json:"displayName"`

			// Rates Array of controlled load rates in order of usage volume
			Rates []struct {
				// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
				MeasureUnit *EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit `json:"measureUnit,omitempty"`

				// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
				UnitPrice string `json:"unitPrice"`

				// Volume Volume in kWh that this rate applies to.  Only applicable for ‘stepped’ rates where different rates apply for different volumes of usage in a period
				Volume *float32 `json:"volume,omitempty"`
			} `json:"rates"`
		} `json:"singleRate,omitempty"`

		// StartDate Optional start date of the application of the controlled load rate
		StartDate *string `json:"startDate,omitempty"`

		// TimeOfUseRates Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
		TimeOfUseRates *[]struct {
			// DailySupplyCharge The daily supply charge (exclusive of GST) for this controlled load tier
			DailySupplyCharge *string `json:"dailySupplyCharge,omitempty"`

			// Description Description of the controlled load rate
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the controlled load rate
			DisplayName string `json:"displayName"`

			// Rates Array of controlled load rates in order of usage volume
			Rates []struct {
				// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
				MeasureUnit *EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit `json:"measureUnit,omitempty"`

				// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
				UnitPrice string `json:"unitPrice"`

				// Volume Volume in kWh that this rate applies to.  Only applicable for ‘stepped’ rates where different rates apply for different volumes of usage in a period
				Volume *float32 `json:"volume,omitempty"`
			} `json:"rates"`

			// TimeOfUse Array of times of use.
			TimeOfUse []struct {
				// AdditionalInfo Display text providing more information on the contrlled load, for e.g. controlled load availability if specific day/time is not known. Required if startTime and endTime absent or if additionalInfoUri provided
				AdditionalInfo *string `json:"additionalInfo,omitempty"`

				// AdditionalInfoUri Optional link to additional information regarding the controlled load
				AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

				// Days The days that the rate applies to
				Days *[]EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays `json:"days,omitempty"`

				// EndTime The end of the time period per day for which the controlled load rate applies. Required if startTime provided
				EndTime *string `json:"endTime,omitempty"`

				// StartTime The beginning of the time period per day for which the controlled load rate applies. Required if endTime provided
				StartTime *string `json:"startTime,omitempty"`
			} `json:"timeOfUse"`

			// Type The type of usage that the rate applies to
			Type EnergyPlanContractControlledLoadTimeOfUseRatesType `json:"type"`
		} `json:"timeOfUseRates,omitempty"`
	} `json:"controlledLoad,omitempty"`

	// Discounts Optional list of discounts available for the contract
	Discounts *[]struct {
		// Category The type of the discount.  Mandatory if the discount type is CONDITIONAL
		Category *EnergyPlanContractDiscountsCategory `json:"category,omitempty"`

		// Description The description of the discount
		Description *string `json:"description,omitempty"`

		// DisplayName The display name of the discount
		DisplayName string `json:"displayName"`

		// EndDate Optional end date for the discount after which the discount is no longer available
		EndDate *string `json:"endDate,omitempty"`

		// FixedAmount Required if methodUType is fixedAmount
		FixedAmount *struct {
			// Amount The amount of the discount
			Amount string `json:"amount"`
		} `json:"fixedAmount,omitempty"`

		// MethodUType The method of calculation of the discount
		MethodUType EnergyPlanContractDiscountsMethodUType `json:"methodUType"`

		// PercentOfBill Required if methodUType is percentOfBill
		PercentOfBill *struct {
			// Rate The rate of the discount applied to the bill amount
			Rate string `json:"rate"`
		} `json:"percentOfBill,omitempty"`

		// PercentOfUse Required if methodUType is percentOfUse
		PercentOfUse *struct {
			// Rate The rate of the discount applied to the usageamount
			Rate string `json:"rate"`
		} `json:"percentOfUse,omitempty"`

		// PercentOverThreshold Required if methodUType is percentOverThreshold
		PercentOverThreshold *struct {
			// Rate The rate of the discount over the usage amount
			Rate string `json:"rate"`

			// UsageAmount The usage amount threshold above which the discount applies
			UsageAmount string `json:"usageAmount"`
		} `json:"percentOverThreshold,omitempty"`

		// Type The type of the discount
		Type EnergyPlanContractDiscountsType `json:"type"`
	} `json:"discounts,omitempty"`

	// Eligibility Eligibility restrictions or requirements
	Eligibility *[]struct {
		// Description A description of the eligibility restriction
		Description *string `json:"description,omitempty"`

		// Information Information of the eligibility restriction specific to the type of the restriction
		Information string `json:"information"`

		// Type The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
		Type EnergyPlanContractEligibilityType `json:"type"`
	} `json:"eligibility,omitempty"`

	// Fees An array of fees applicable to the plan
	Fees *[]struct {
		// Amount The fee amount. Required if term is not PERCENT_OF_BILL
		Amount *string `json:"amount,omitempty"`

		// Description A description of the fee
		Description *string `json:"description,omitempty"`

		// Rate The fee rate. Required if term is PERCENT_OF_BILL
		Rate *string `json:"rate,omitempty"`

		// Term The term of the fee
		Term EnergyPlanContractFeesTerm `json:"term"`

		// Type The type of the fee
		Type EnergyPlanContractFeesType `json:"type"`
	} `json:"fees,omitempty"`

	// GreenPowerCharges Optional list of charges applicable to green power
	GreenPowerCharges *[]struct {
		// Description The description of the charge
		Description *string `json:"description,omitempty"`

		// DisplayName The display name of the charge
		DisplayName string `json:"displayName"`

		// Scheme The applicable green power scheme
		Scheme EnergyPlanContractGreenPowerChargesScheme `json:"scheme"`

		// Tiers Array of charge tiers based on the percentage of green power used for the period implied by the type.  Array is in order of increasing percentage of green power
		Tiers []struct {
			// Amount The amount of the charge if the type implies the application of a fixed amount
			Amount *string `json:"amount,omitempty"`

			// PercentGreen The upper percentage of green power used applicable for this tier
			PercentGreen string `json:"percentGreen"`

			// Rate The rate of the charge if the type implies the application of a rate
			Rate *string `json:"rate,omitempty"`
		} `json:"tiers"`

		// Type The type of charge
		Type EnergyPlanContractGreenPowerChargesType `json:"type"`
	} `json:"greenPowerCharges,omitempty"`

	// Incentives Optional list of incentives available for the contract
	Incentives *[]struct {
		// Category The type of the incentive
		Category EnergyPlanContractIncentivesCategory `json:"category"`

		// Description The description of the incentive
		Description string `json:"description"`

		// DisplayName The display name of the incentive
		DisplayName string `json:"displayName"`

		// Eligibility A display message outlining an eligibility criteria that may apply
		Eligibility *string `json:"eligibility,omitempty"`
	} `json:"incentives,omitempty"`

	// IntrinsicGreenPower Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
	IntrinsicGreenPower *EnergyPlanContractIntrinsicGreenPower `json:"intrinsicGreenPower,omitempty"`

	// IsFixed Flag indicating whether prices are fixed or variable
	IsFixed bool `json:"isFixed"`

	// OnExpiryDescription Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
	OnExpiryDescription *string `json:"onExpiryDescription,omitempty"`

	// PaymentOption Payment options for this contract
	PaymentOption []EnergyPlanContractPaymentOption `json:"paymentOption"`

	// PricingModel The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
	PricingModel EnergyPlanContractPricingModel `json:"pricingModel"`

	// SolarFeedInTariff Array of feed in tariffs for solar power
	SolarFeedInTariff *[]struct {
		// Description A description of the tariff
		Description *string `json:"description,omitempty"`

		// DisplayName The name of the tariff
		DisplayName string `json:"displayName"`

		// PayerType The type of the payer
		PayerType EnergyPlanContractSolarFeedInTariffPayerType `json:"payerType"`

		// Scheme The applicable scheme
		Scheme EnergyPlanContractSolarFeedInTariffScheme `json:"scheme"`

		// SingleTariff Represents a constant tariff.  Mandatory if tariffUType is set to singleTariff
		SingleTariff *struct {
			// Amount The tariff amount
			Amount string `json:"amount"`
		} `json:"singleTariff,omitempty"`

		// TariffUType The type of the payer
		TariffUType EnergyPlanContractSolarFeedInTariffTariffUType `json:"tariffUType"`

		// TimeVaryingTariffs Represents a tariff based on time.  Mandatory if tariffUType is set to timeVaryingTariffs
		TimeVaryingTariffs *struct {
			// Amount The tariff amount
			Amount string `json:"amount"`

			// TimeVariations Array of time periods for which this tariff is applicable
			TimeVariations []struct {
				// Days The days that the tariff applies to. At least one entry required
				Days []EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays `json:"days"`

				// EndTime The end of the time period per day for which the tariff applies.  If absent assumes end of day (ie. one second before midnight)
				EndTime *string `json:"endTime,omitempty"`

				// StartTime The beginning of the time period per day for which the tariff applies.  If absent assumes start of day (ie. midnight)
				StartTime *string `json:"startTime,omitempty"`
			} `json:"timeVariations"`

			// Type The type of the charging time period. If absent applies to all periods
			Type *EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsType `json:"type,omitempty"`
		} `json:"timeVaryingTariffs,omitempty"`
	} `json:"solarFeedInTariff,omitempty"`

	// TariffPeriod Array of tariff periods
	TariffPeriod []struct {
		// DailySupplyCharges The amount of access charge for the tariff period, in dollars per day exclusive of GST.
		DailySupplyCharges *string `json:"dailySupplyCharges,omitempty"`

		// DemandCharges Array of demand charges.  Required if rateBlockUType is demandCharges
		DemandCharges *[]struct {
			// Amount The charge amount per  measure unit exclusive of GST
			Amount string `json:"amount"`

			// ChargePeriod Charge period for the demand tariff
			ChargePeriod EnergyPlanContractTariffPeriodDemandChargesChargePeriod `json:"chargePeriod"`

			// Days The days that the demand tariff applies to
			Days *[]EnergyPlanContractTariffPeriodDemandChargesDays `json:"days,omitempty"`

			// Description Description of the charge
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the charge
			DisplayName string `json:"displayName"`

			// EndTime End of the period
			EndTime string `json:"endTime"`

			// MaxDemand Maximum demand for this demand tariff in kW.  If present, must be higher than the value of the minDemand field
			MaxDemand *string `json:"maxDemand,omitempty"`

			// MeasureUnit The measurement unit of charge amount. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanContractTariffPeriodDemandChargesMeasureUnit `json:"measureUnit,omitempty"`

			// MeasurementPeriod Application period for the demand tariff
			MeasurementPeriod EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriod `json:"measurementPeriod"`

			// MinDemand Minimum demand for this demand tariff in kW.  If absent then 0 is assumed
			MinDemand *string `json:"minDemand,omitempty"`

			// StartTime Start of the period
			StartTime string `json:"startTime"`
		} `json:"demandCharges,omitempty"`

		// DisplayName The name of the tariff period
		DisplayName string `json:"displayName"`

		// EndDate The end date of the tariff period in a calendar year.  Formatted in mm-dd format
		EndDate string `json:"endDate"`

		// RateBlockUType Specifies the type of rate applicable to this tariff period
		RateBlockUType EnergyPlanContractTariffPeriodRateBlockUType `json:"rateBlockUType"`

		// SingleRate Object representing a single rate.  Required if rateBlockUType is singleRate
		SingleRate *struct {
			// Description Description of the rate
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the rate
			DisplayName string `json:"displayName"`

			// GeneralUnitPrice The block rate (unit price) for any usage above the included fixed usage, in dollars per kWh inclusive of GST.  Only required if pricingModel field is ‘QUOTA’
			GeneralUnitPrice *string `json:"generalUnitPrice,omitempty"`

			// Period Usage period for which the block rate applies. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
			Period *string `json:"period,omitempty"`

			// Rates Array of controlled load rates in order of usage volume
			Rates []struct {
				// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
				MeasureUnit *EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit `json:"measureUnit,omitempty"`

				// UnitPrice Unit price of usage per measure unit (exclusive of GST)
				UnitPrice string `json:"unitPrice"`

				// Volume Volume in kWh that this rate applies to.  Only applicable for ‘stepped’ rates where different rates apply for different volumes of usage in a period
				Volume *float32 `json:"volume,omitempty"`
			} `json:"rates"`
		} `json:"singleRate,omitempty"`

		// StartDate The start date of the tariff period in a calendar year.  Formatted in mm-dd format
		StartDate string `json:"startDate"`

		// TimeOfUseRates Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
		TimeOfUseRates *[]struct {
			// Description Description of the rate
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the rate
			DisplayName string `json:"displayName"`

			// Rates Array of controlled load rates in order of usage volume
			Rates []struct {
				// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
				MeasureUnit *EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit `json:"measureUnit,omitempty"`

				// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
				UnitPrice string `json:"unitPrice"`

				// Volume Volume in kWh that this rate applies to.  Only applicable for ‘stepped’ rates where different rates apply for different volumes of usage in a period
				Volume *float32 `json:"volume,omitempty"`
			} `json:"rates"`

			// TimeOfUse Array of times of use
			TimeOfUse []struct {
				// Days The days that the rate applies to
				Days []EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays `json:"days"`

				// EndTime End of the period
				EndTime string `json:"endTime"`

				// StartTime Start of the period
				StartTime string `json:"startTime"`
			} `json:"timeOfUse"`

			// Type The type of usage that the rate applies to
			Type EnergyPlanContractTariffPeriodTimeOfUseRatesType `json:"type"`
		} `json:"timeOfUseRates,omitempty"`

		// TimeZone Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
		TimeZone *EnergyPlanContractTariffPeriodTimeZone `json:"timeZone,omitempty"`

		// Type Type of charge. Assumed to be other if absent
		Type *EnergyPlanContractTariffPeriodType `json:"type,omitempty"`
	} `json:"tariffPeriod"`

	// TimeZone Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
	TimeZone *EnergyPlanContractTimeZone `json:"timeZone,omitempty"`

	// Variation Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
	Variation *string `json:"variation,omitempty"`
}

// EnergyPlanContractControlledLoadRateBlockUType Specifies the type of controlloed load rate
type EnergyPlanContractControlledLoadRateBlockUType string

// EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanContractControlledLoadSingleRateRatesMeasureUnit string

// EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanContractControlledLoadTimeOfUseRatesRatesMeasureUnit string

// EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays defines model for EnergyPlanContract.ControlledLoad.TimeOfUseRates.TimeOfUse.Days.
type EnergyPlanContractControlledLoadTimeOfUseRatesTimeOfUseDays string

// EnergyPlanContractControlledLoadTimeOfUseRatesType The type of usage that the rate applies to
type EnergyPlanContractControlledLoadTimeOfUseRatesType string

// EnergyPlanContractDiscountsCategory The type of the discount.  Mandatory if the discount type is CONDITIONAL
type EnergyPlanContractDiscountsCategory string

// EnergyPlanContractDiscountsMethodUType The method of calculation of the discount
type EnergyPlanContractDiscountsMethodUType string

// EnergyPlanContractDiscountsType The type of the discount
type EnergyPlanContractDiscountsType string

// EnergyPlanContractEligibilityType The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
type EnergyPlanContractEligibilityType string

// EnergyPlanContractFeesTerm The term of the fee
type EnergyPlanContractFeesTerm string

// EnergyPlanContractFeesType The type of the fee
type EnergyPlanContractFeesType string

// EnergyPlanContractGreenPowerChargesScheme The applicable green power scheme
type EnergyPlanContractGreenPowerChargesScheme string

// EnergyPlanContractGreenPowerChargesType The type of charge
type EnergyPlanContractGreenPowerChargesType string

// EnergyPlanContractIncentivesCategory The type of the incentive
type EnergyPlanContractIncentivesCategory string

// EnergyPlanContractPaymentOption defines model for EnergyPlanContract.PaymentOption.
type EnergyPlanContractPaymentOption string

// EnergyPlanContractPricingModel The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
type EnergyPlanContractPricingModel string

// EnergyPlanContractSolarFeedInTariffPayerType The type of the payer
type EnergyPlanContractSolarFeedInTariffPayerType string

// EnergyPlanContractSolarFeedInTariffScheme The applicable scheme
type EnergyPlanContractSolarFeedInTariffScheme string

// EnergyPlanContractSolarFeedInTariffTariffUType The type of the payer
type EnergyPlanContractSolarFeedInTariffTariffUType string

// EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays defines model for EnergyPlanContract.SolarFeedInTariff.TimeVaryingTariffs.TimeVariations.Days.
type EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays string

// EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsType The type of the charging time period. If absent applies to all periods
type EnergyPlanContractSolarFeedInTariffTimeVaryingTariffsType string

// EnergyPlanContractTariffPeriodDemandChargesChargePeriod Charge period for the demand tariff
type EnergyPlanContractTariffPeriodDemandChargesChargePeriod string

// EnergyPlanContractTariffPeriodDemandChargesDays defines model for EnergyPlanContract.TariffPeriod.DemandCharges.Days.
type EnergyPlanContractTariffPeriodDemandChargesDays string

// EnergyPlanContractTariffPeriodDemandChargesMeasureUnit The measurement unit of charge amount. Assumed to be KWH if absent
type EnergyPlanContractTariffPeriodDemandChargesMeasureUnit string

// EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriod Application period for the demand tariff
type EnergyPlanContractTariffPeriodDemandChargesMeasurementPeriod string

// EnergyPlanContractTariffPeriodRateBlockUType Specifies the type of rate applicable to this tariff period
type EnergyPlanContractTariffPeriodRateBlockUType string

// EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanContractTariffPeriodSingleRateRatesMeasureUnit string

// EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanContractTariffPeriodTimeOfUseRatesRatesMeasureUnit string

// EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays defines model for EnergyPlanContract.TariffPeriod.TimeOfUseRates.TimeOfUse.Days.
type EnergyPlanContractTariffPeriodTimeOfUseRatesTimeOfUseDays string

// EnergyPlanContractTariffPeriodTimeOfUseRatesType The type of usage that the rate applies to
type EnergyPlanContractTariffPeriodTimeOfUseRatesType string

// EnergyPlanContractTariffPeriodTimeZone Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
type EnergyPlanContractTariffPeriodTimeZone string

// EnergyPlanContractTariffPeriodType Type of charge. Assumed to be other if absent
type EnergyPlanContractTariffPeriodType string

// EnergyPlanContractTimeZone Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
type EnergyPlanContractTimeZone string

// EnergyPlanContractFull defines model for EnergyPlanContractFull.
type EnergyPlanContractFull struct {
	// AdditionalFeeInformation Free text field containing additional information of the fees for this contract
	AdditionalFeeInformation *string `json:"additionalFeeInformation,omitempty"`

	// BenefitPeriod Description of the benefit period.  Should only be present if termType has the value ONGOING
	BenefitPeriod *string `json:"benefitPeriod,omitempty"`

	// BillFrequency An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	BillFrequency []string `json:"billFrequency"`

	// ControlledLoad Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
	ControlledLoad *[]struct {
		// DisplayName A display name for the controlled load
		DisplayName string `json:"displayName"`

		// EndDate Optional end date of the application of the controlled load rate
		EndDate *string `json:"endDate,omitempty"`

		// RateBlockUType Specifies the type of controlloed load rate
		RateBlockUType EnergyPlanContractFullControlledLoadRateBlockUType `json:"rateBlockUType"`

		// SingleRate Object representing a single controlled load rate.  Required if rateBlockUType is singleRate
		SingleRate *struct {
			// DailySupplyCharge The daily supply charge (exclusive of GST) for this controlled load tier
			DailySupplyCharge *string `json:"dailySupplyCharge,omitempty"`

			// Description Description of the controlled load rate
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the controlled load rate
			DisplayName string `json:"displayName"`

			// Rates Array of controlled load rates in order of usage volume
			Rates []struct {
				// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
				MeasureUnit *EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit `json:"measureUnit,omitempty"`

				// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
				UnitPrice string `json:"unitPrice"`

				// Volume Volume in kWh that this rate applies to.  Only applicable for ‘stepped’ rates where different rates apply for different volumes of usage in a period
				Volume *float32 `json:"volume,omitempty"`
			} `json:"rates"`
		} `json:"singleRate,omitempty"`

		// StartDate Optional start date of the application of the controlled load rate
		StartDate *string `json:"startDate,omitempty"`

		// TimeOfUseRates Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
		TimeOfUseRates *[]struct {
			// DailySupplyCharge The daily supply charge (exclusive of GST) for this controlled load tier
			DailySupplyCharge *string `json:"dailySupplyCharge,omitempty"`

			// Description Description of the controlled load rate
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the controlled load rate
			DisplayName string `json:"displayName"`

			// Rates Array of controlled load rates in order of usage volume
			Rates []struct {
				// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
				MeasureUnit *EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit `json:"measureUnit,omitempty"`

				// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
				UnitPrice string `json:"unitPrice"`

				// Volume Volume in kWh that this rate applies to.  Only applicable for ‘stepped’ rates where different rates apply for different volumes of usage in a period
				Volume *float32 `json:"volume,omitempty"`
			} `json:"rates"`

			// TimeOfUse Array of times of use.
			TimeOfUse []struct {
				// AdditionalInfo Display text providing more information on the contrlled load, for e.g. controlled load availability if specific day/time is not known. Required if startTime and endTime absent or if additionalInfoUri provided
				AdditionalInfo *string `json:"additionalInfo,omitempty"`

				// AdditionalInfoUri Optional link to additional information regarding the controlled load
				AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

				// Days The days that the rate applies to
				Days *[]EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays `json:"days,omitempty"`

				// EndTime The end of the time period per day for which the controlled load rate applies. Required if startTime provided
				EndTime *string `json:"endTime,omitempty"`

				// StartTime The beginning of the time period per day for which the controlled load rate applies. Required if endTime provided
				StartTime *string `json:"startTime,omitempty"`
			} `json:"timeOfUse"`

			// Type The type of usage that the rate applies to
			Type EnergyPlanContractFullControlledLoadTimeOfUseRatesType `json:"type"`
		} `json:"timeOfUseRates,omitempty"`
	} `json:"controlledLoad,omitempty"`

	// CoolingOffDays Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
	// Note: This was originally an *int but I changed it to a *json.Number because some providers
	// send through a string. json.Number accepts both ints and strings as a "feature".
	// https://github.com/golang/go/issues/34472
	CoolingOffDays *json.Number `json:"coolingOffDays,omitempty"`

	// Discounts Optional list of discounts available for the contract
	Discounts *[]struct {
		// Category The type of the discount.  Mandatory if the discount type is CONDITIONAL
		Category *EnergyPlanContractFullDiscountsCategory `json:"category,omitempty"`

		// Description The description of the discount
		Description *string `json:"description,omitempty"`

		// DisplayName The display name of the discount
		DisplayName string `json:"displayName"`

		// EndDate Optional end date for the discount after which the discount is no longer available
		EndDate *string `json:"endDate,omitempty"`

		// FixedAmount Required if methodUType is fixedAmount
		FixedAmount *struct {
			// Amount The amount of the discount
			Amount string `json:"amount"`
		} `json:"fixedAmount,omitempty"`

		// MethodUType The method of calculation of the discount
		MethodUType EnergyPlanContractFullDiscountsMethodUType `json:"methodUType"`

		// PercentOfBill Required if methodUType is percentOfBill
		PercentOfBill *struct {
			// Rate The rate of the discount applied to the bill amount
			Rate string `json:"rate"`
		} `json:"percentOfBill,omitempty"`

		// PercentOfUse Required if methodUType is percentOfUse
		PercentOfUse *struct {
			// Rate The rate of the discount applied to the usageamount
			Rate string `json:"rate"`
		} `json:"percentOfUse,omitempty"`

		// PercentOverThreshold Required if methodUType is percentOverThreshold
		PercentOverThreshold *struct {
			// Rate The rate of the discount over the usage amount
			Rate string `json:"rate"`

			// UsageAmount The usage amount threshold above which the discount applies
			UsageAmount string `json:"usageAmount"`
		} `json:"percentOverThreshold,omitempty"`

		// Type The type of the discount
		Type EnergyPlanContractFullDiscountsType `json:"type"`
	} `json:"discounts,omitempty"`

	// Eligibility Eligibility restrictions or requirements
	Eligibility *[]struct {
		// Description A description of the eligibility restriction
		Description *string `json:"description,omitempty"`

		// Information Information of the eligibility restriction specific to the type of the restriction
		Information string `json:"information"`

		// Type The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
		Type EnergyPlanContractFullEligibilityType `json:"type"`
	} `json:"eligibility,omitempty"`

	// Fees An array of fees applicable to the plan
	Fees *[]struct {
		// Amount The fee amount. Required if term is not PERCENT_OF_BILL
		Amount *string `json:"amount,omitempty"`

		// Description A description of the fee
		Description *string `json:"description,omitempty"`

		// Rate The fee rate. Required if term is PERCENT_OF_BILL
		Rate *string `json:"rate,omitempty"`

		// Term The term of the fee
		Term EnergyPlanContractFullFeesTerm `json:"term"`

		// Type The type of the fee
		Type EnergyPlanContractFullFeesType `json:"type"`
	} `json:"fees,omitempty"`

	// GreenPowerCharges Optional list of charges applicable to green power
	GreenPowerCharges *[]struct {
		// Description The description of the charge
		Description *string `json:"description,omitempty"`

		// DisplayName The display name of the charge
		DisplayName string `json:"displayName"`

		// Scheme The applicable green power scheme
		Scheme EnergyPlanContractFullGreenPowerChargesScheme `json:"scheme"`

		// Tiers Array of charge tiers based on the percentage of green power used for the period implied by the type.  Array is in order of increasing percentage of green power
		Tiers []struct {
			// Amount The amount of the charge if the type implies the application of a fixed amount
			Amount *string `json:"amount,omitempty"`

			// PercentGreen The upper percentage of green power used applicable for this tier
			PercentGreen string `json:"percentGreen"`

			// Rate The rate of the charge if the type implies the application of a rate
			Rate *string `json:"rate,omitempty"`
		} `json:"tiers"`

		// Type The type of charge
		Type EnergyPlanContractFullGreenPowerChargesType `json:"type"`
	} `json:"greenPowerCharges,omitempty"`

	// Incentives Optional list of incentives available for the contract
	Incentives *[]struct {
		// Category The type of the incentive
		Category EnergyPlanContractFullIncentivesCategory `json:"category"`

		// Description The description of the incentive
		Description string `json:"description"`

		// DisplayName The display name of the incentive
		DisplayName string `json:"displayName"`

		// Eligibility A display message outlining an eligibility criteria that may apply
		Eligibility *string `json:"eligibility,omitempty"`
	} `json:"incentives,omitempty"`

	// IntrinsicGreenPower Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
	IntrinsicGreenPower *EnergyPlanContractIntrinsicGreenPower `json:"intrinsicGreenPower,omitempty"`

	// IsFixed Flag indicating whether prices are fixed or variable
	IsFixed bool `json:"isFixed"`

	// MeterTypes An array of the meter types that this contract is available for
	MeterTypes *[]string `json:"meterTypes,omitempty"`

	// OnExpiryDescription Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
	OnExpiryDescription *string `json:"onExpiryDescription,omitempty"`

	// PaymentOption Payment options for this contract
	PaymentOption []EnergyPlanContractFullPaymentOption `json:"paymentOption"`

	// PricingModel The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
	PricingModel EnergyPlanContractFullPricingModel `json:"pricingModel"`

	// SolarFeedInTariff Array of feed in tariffs for solar power
	SolarFeedInTariff *[]struct {
		// Description A description of the tariff
		Description *string `json:"description,omitempty"`

		// DisplayName The name of the tariff
		DisplayName string `json:"displayName"`

		// PayerType The type of the payer
		PayerType EnergyPlanContractFullSolarFeedInTariffPayerType `json:"payerType"`

		// Scheme The applicable scheme
		Scheme EnergyPlanContractFullSolarFeedInTariffScheme `json:"scheme"`

		// SingleTariff Represents a constant tariff.  Mandatory if tariffUType is set to singleTariff
		SingleTariff *struct {
			// Amount The tariff amount
			Amount string `json:"amount"`
		} `json:"singleTariff,omitempty"`

		// TariffUType The type of the payer
		TariffUType EnergyPlanContractFullSolarFeedInTariffTariffUType `json:"tariffUType"`

		// TimeVaryingTariffs Represents a tariff based on time.  Mandatory if tariffUType is set to timeVaryingTariffs
		TimeVaryingTariffs *struct {
			// Amount The tariff amount
			Amount string `json:"amount"`

			// TimeVariations Array of time periods for which this tariff is applicable
			TimeVariations []struct {
				// Days The days that the tariff applies to. At least one entry required
				Days []EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays `json:"days"`

				// EndTime The end of the time period per day for which the tariff applies.  If absent assumes end of day (ie. one second before midnight)
				EndTime *string `json:"endTime,omitempty"`

				// StartTime The beginning of the time period per day for which the tariff applies.  If absent assumes start of day (ie. midnight)
				StartTime *string `json:"startTime,omitempty"`
			} `json:"timeVariations"`

			// Type The type of the charging time period. If absent applies to all periods
			Type *EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsType `json:"type,omitempty"`
		} `json:"timeVaryingTariffs,omitempty"`
	} `json:"solarFeedInTariff,omitempty"`

	// TariffPeriod Array of tariff periods
	TariffPeriod []struct {
		// DailySupplyCharges The amount of access charge for the tariff period, in dollars per day exclusive of GST.
		DailySupplyCharges *string `json:"dailySupplyCharges,omitempty"`

		// DemandCharges Array of demand charges.  Required if rateBlockUType is demandCharges
		DemandCharges *[]struct {
			// Amount The charge amount per  measure unit exclusive of GST
			Amount string `json:"amount"`

			// ChargePeriod Charge period for the demand tariff
			ChargePeriod EnergyPlanContractFullTariffPeriodDemandChargesChargePeriod `json:"chargePeriod"`

			// Days The days that the demand tariff applies to
			Days *[]EnergyPlanContractFullTariffPeriodDemandChargesDays `json:"days,omitempty"`

			// Description Description of the charge
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the charge
			DisplayName string `json:"displayName"`

			// EndTime End of the period
			EndTime string `json:"endTime"`

			// MaxDemand Maximum demand for this demand tariff in kW.  If present, must be higher than the value of the minDemand field
			MaxDemand *string `json:"maxDemand,omitempty"`

			// MeasureUnit The measurement unit of charge amount. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit `json:"measureUnit,omitempty"`

			// MeasurementPeriod Application period for the demand tariff
			MeasurementPeriod EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriod `json:"measurementPeriod"`

			// MinDemand Minimum demand for this demand tariff in kW.  If absent then 0 is assumed
			MinDemand *string `json:"minDemand,omitempty"`

			// StartTime Start of the period
			StartTime string `json:"startTime"`
		} `json:"demandCharges,omitempty"`

		// DisplayName The name of the tariff period
		DisplayName string `json:"displayName"`

		// EndDate The end date of the tariff period in a calendar year.  Formatted in mm-dd format
		EndDate string `json:"endDate"`

		// RateBlockUType Specifies the type of rate applicable to this tariff period
		RateBlockUType EnergyPlanContractFullTariffPeriodRateBlockUType `json:"rateBlockUType"`

		// SingleRate Object representing a single rate.  Required if rateBlockUType is singleRate
		SingleRate *struct {
			// Description Description of the rate
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the rate
			DisplayName string `json:"displayName"`

			// GeneralUnitPrice The block rate (unit price) for any usage above the included fixed usage, in dollars per kWh inclusive of GST.  Only required if pricingModel field is ‘QUOTA’
			GeneralUnitPrice *string `json:"generalUnitPrice,omitempty"`

			// Period Usage period for which the block rate applies. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
			Period *string `json:"period,omitempty"`

			// Rates Array of controlled load rates in order of usage volume
			Rates []struct {
				// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
				MeasureUnit *EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit `json:"measureUnit,omitempty"`

				// UnitPrice Unit price of usage per measure unit (exclusive of GST)
				UnitPrice string `json:"unitPrice"`

				// Volume Volume in kWh that this rate applies to.  Only applicable for ‘stepped’ rates where different rates apply for different volumes of usage in a period
				Volume *float32 `json:"volume,omitempty"`
			} `json:"rates"`
		} `json:"singleRate,omitempty"`

		// StartDate The start date of the tariff period in a calendar year.  Formatted in mm-dd format
		StartDate string `json:"startDate"`

		// TimeOfUseRates Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
		TimeOfUseRates *[]struct {
			// Description Description of the rate
			Description *string `json:"description,omitempty"`

			// DisplayName Display name of the rate
			DisplayName string `json:"displayName"`

			// Rates Array of controlled load rates in order of usage volume
			Rates []struct {
				// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
				MeasureUnit *EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit `json:"measureUnit,omitempty"`

				// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
				UnitPrice string `json:"unitPrice"`

				// Volume Volume in kWh that this rate applies to.  Only applicable for ‘stepped’ rates where different rates apply for different volumes of usage in a period
				Volume *float32 `json:"volume,omitempty"`
			} `json:"rates"`

			// TimeOfUse Array of times of use
			TimeOfUse []struct {
				// Days The days that the rate applies to
				Days []EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays `json:"days"`

				// EndTime End of the period
				EndTime string `json:"endTime"`

				// StartTime Start of the period
				StartTime string `json:"startTime"`
			} `json:"timeOfUse"`

			// Type The type of usage that the rate applies to
			Type EnergyPlanContractFullTariffPeriodTimeOfUseRatesType `json:"type"`
		} `json:"timeOfUseRates,omitempty"`

		// TimeZone Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
		TimeZone *EnergyPlanContractFullTariffPeriodTimeZone `json:"timeZone,omitempty"`

		// Type Type of charge. Assumed to be other if absent
		Type *EnergyPlanContractFullTariffPeriodType `json:"type,omitempty"`
	} `json:"tariffPeriod"`

	// TermType The term for the contract.  If absent assumes no specified term
	TermType *EnergyPlanContractFullTermType `json:"termType,omitempty"`

	// Terms Free text description of the terms for the contract
	Terms *string `json:"terms,omitempty"`

	// TimeZone Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
	TimeZone *EnergyPlanContractFullTimeZone `json:"timeZone,omitempty"`

	// Variation Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
	Variation *string `json:"variation,omitempty"`
}

// EnergyPlanContractFullControlledLoadRateBlockUType Specifies the type of controlloed load rate
type EnergyPlanContractFullControlledLoadRateBlockUType string

// EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanContractFullControlledLoadSingleRateRatesMeasureUnit string

// EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanContractFullControlledLoadTimeOfUseRatesRatesMeasureUnit string

// EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays defines model for EnergyPlanContractFull.ControlledLoad.TimeOfUseRates.TimeOfUse.Days.
type EnergyPlanContractFullControlledLoadTimeOfUseRatesTimeOfUseDays string

// EnergyPlanContractFullControlledLoadTimeOfUseRatesType The type of usage that the rate applies to
type EnergyPlanContractFullControlledLoadTimeOfUseRatesType string

// EnergyPlanContractFullDiscountsCategory The type of the discount.  Mandatory if the discount type is CONDITIONAL
type EnergyPlanContractFullDiscountsCategory string

// EnergyPlanContractFullDiscountsMethodUType The method of calculation of the discount
type EnergyPlanContractFullDiscountsMethodUType string

// EnergyPlanContractFullDiscountsType The type of the discount
type EnergyPlanContractFullDiscountsType string

// EnergyPlanContractFullEligibilityType The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
type EnergyPlanContractFullEligibilityType string

// EnergyPlanContractFullFeesTerm The term of the fee
type EnergyPlanContractFullFeesTerm string

// EnergyPlanContractFullFeesType The type of the fee
type EnergyPlanContractFullFeesType string

// EnergyPlanContractFullGreenPowerChargesScheme The applicable green power scheme
type EnergyPlanContractFullGreenPowerChargesScheme string

// EnergyPlanContractFullGreenPowerChargesType The type of charge
type EnergyPlanContractFullGreenPowerChargesType string

// EnergyPlanContractFullIncentivesCategory The type of the incentive
type EnergyPlanContractFullIncentivesCategory string

// EnergyPlanContractFullPaymentOption defines model for EnergyPlanContractFull.PaymentOption.
type EnergyPlanContractFullPaymentOption string

// EnergyPlanContractFullPricingModel The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a ‘block’ or ‘step’ tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a ‘subscription’ or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
type EnergyPlanContractFullPricingModel string

// EnergyPlanContractFullSolarFeedInTariffPayerType The type of the payer
type EnergyPlanContractFullSolarFeedInTariffPayerType string

// EnergyPlanContractFullSolarFeedInTariffScheme The applicable scheme
type EnergyPlanContractFullSolarFeedInTariffScheme string

// EnergyPlanContractFullSolarFeedInTariffTariffUType The type of the payer
type EnergyPlanContractFullSolarFeedInTariffTariffUType string

// EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays defines model for EnergyPlanContractFull.SolarFeedInTariff.TimeVaryingTariffs.TimeVariations.Days.
type EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays string

// EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsType The type of the charging time period. If absent applies to all periods
type EnergyPlanContractFullSolarFeedInTariffTimeVaryingTariffsType string

// EnergyPlanContractFullTariffPeriodDemandChargesChargePeriod Charge period for the demand tariff
type EnergyPlanContractFullTariffPeriodDemandChargesChargePeriod string

// EnergyPlanContractFullTariffPeriodDemandChargesDays defines model for EnergyPlanContractFull.TariffPeriod.DemandCharges.Days.
type EnergyPlanContractFullTariffPeriodDemandChargesDays string

// EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit The measurement unit of charge amount. Assumed to be KWH if absent
type EnergyPlanContractFullTariffPeriodDemandChargesMeasureUnit string

// EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriod Application period for the demand tariff
type EnergyPlanContractFullTariffPeriodDemandChargesMeasurementPeriod string

// EnergyPlanContractFullTariffPeriodRateBlockUType Specifies the type of rate applicable to this tariff period
type EnergyPlanContractFullTariffPeriodRateBlockUType string

// EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanContractFullTariffPeriodSingleRateRatesMeasureUnit string

// EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanContractFullTariffPeriodTimeOfUseRatesRatesMeasureUnit string

// EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays defines model for EnergyPlanContractFull.TariffPeriod.TimeOfUseRates.TimeOfUse.Days.
type EnergyPlanContractFullTariffPeriodTimeOfUseRatesTimeOfUseDays string

// EnergyPlanContractFullTariffPeriodTimeOfUseRatesType The type of usage that the rate applies to
type EnergyPlanContractFullTariffPeriodTimeOfUseRatesType string

// EnergyPlanContractFullTariffPeriodTimeZone Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
type EnergyPlanContractFullTariffPeriodTimeZone string

// EnergyPlanContractFullTariffPeriodType Type of charge. Assumed to be other if absent
type EnergyPlanContractFullTariffPeriodType string

// EnergyPlanContractFullTermType The term for the contract.  If absent assumes no specified term
type EnergyPlanContractFullTermType string

// EnergyPlanContractFullTimeZone Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
type EnergyPlanContractFullTimeZone string

// EnergyPlanContractFullAllOf defines model for EnergyPlanContractFull_allOf.
type EnergyPlanContractFullAllOf struct {
	// BenefitPeriod Description of the benefit period.  Should only be present if termType has the value ONGOING
	BenefitPeriod *string `json:"benefitPeriod,omitempty"`

	// BillFrequency An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	BillFrequency []string `json:"billFrequency"`

	// CoolingOffDays Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
	// Note: This was originally an *int but I changed it to a *json.Number because some providers
	// send through a string. json.Number accepts both ints and strings as a "feature".
	// https://github.com/golang/go/issues/34472
	CoolingOffDays *json.Number `json:"coolingOffDays,omitempty"`

	// MeterTypes An array of the meter types that this contract is available for
	MeterTypes *[]string `json:"meterTypes,omitempty"`

	// TermType The term for the contract.  If absent assumes no specified term
	TermType *EnergyPlanContractFullAllOfTermType `json:"termType,omitempty"`

	// Terms Free text description of the terms for the contract
	Terms *string `json:"terms,omitempty"`
}

// EnergyPlanContractFullAllOfTermType The term for the contract.  If absent assumes no specified term
type EnergyPlanContractFullAllOfTermType string

// EnergyPlanContractIntrinsicGreenPower Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
type EnergyPlanContractIntrinsicGreenPower struct {
	// GreenPercentage Percentage of green power intrinsically included in the plan
	GreenPercentage string `json:"greenPercentage"`
}

// EnergyPlanDetail defines model for EnergyPlanDetail.
type EnergyPlanDetail struct {
	// AdditionalInformation Object that contains links to additional information on specific topics
	AdditionalInformation *EnergyPlanAdditionalInformation `json:"additionalInformation,omitempty"`

	// ApplicationUri A link to an application web page where this plan can be applied for
	ApplicationUri *string `json:"applicationUri,omitempty"`

	// Brand The ID of the brand under which this plan is offered
	Brand string `json:"brand"`

	// BrandName The display name of the brand under which this plan is offered
	BrandName string `json:"brandName"`

	// CustomerType The type of customer that the plan is offered to.  If absent then the plan is available to all customers
	CustomerType *EnergyPlanDetailCustomerType `json:"customerType,omitempty"`

	// Description A description of the plan
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the plan
	DisplayName *string `json:"displayName,omitempty"`

	// EffectiveFrom The date and time from which this plan is effective (ie. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
	EffectiveTo         *string                 `json:"effectiveTo,omitempty"`
	ElectricityContract *EnergyPlanContractFull `json:"electricityContract,omitempty"`

	// FuelType The fuel types covered by the plan
	FuelType    EnergyPlanDetailFuelType `json:"fuelType"`
	GasContract *EnergyPlanContractFull  `json:"gasContract,omitempty"`

	// Geography Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
	Geography *EnergyPlanGeography `json:"geography,omitempty"`

	// LastUpdated The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
	LastUpdated string `json:"lastUpdated"`

	// MeteringCharges Charges for metering included in the plan
	MeteringCharges *[]EnergyPlanDetailAllOfMeteringCharges `json:"meteringCharges,omitempty"`

	// PlanId The ID of the specific plan
	PlanId string `json:"planId"`

	// Type The type of the plan
	Type EnergyPlanDetailType `json:"type"`
}

// EnergyPlanDetailCustomerType The type of customer that the plan is offered to.  If absent then the plan is available to all customers
type EnergyPlanDetailCustomerType string

// EnergyPlanDetailFuelType The fuel types covered by the plan
type EnergyPlanDetailFuelType string

// EnergyPlanDetailType The type of the plan
type EnergyPlanDetailType string

// EnergyPlanDetailAllOf defines model for EnergyPlanDetail_allOf.
type EnergyPlanDetailAllOf struct {
	ElectricityContract *EnergyPlanContractFull `json:"electricityContract,omitempty"`
	GasContract         *EnergyPlanContractFull `json:"gasContract,omitempty"`

	// MeteringCharges Charges for metering included in the plan
	MeteringCharges *[]EnergyPlanDetailAllOfMeteringCharges `json:"meteringCharges,omitempty"`
}

// EnergyPlanDetailAllOfMeteringCharges defines model for EnergyPlanDetail_allOf_meteringCharges.
type EnergyPlanDetailAllOfMeteringCharges struct {
	// Description Description of the charge
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the charge
	DisplayName string `json:"displayName"`

	// MaximumValue The upper limit of the charge if the charge could occur in a range
	MaximumValue *string `json:"maximumValue,omitempty"`

	// MinimumValue Minimum value of the charge if the charge is a range or the absolute value of the charge if no range is specified
	MinimumValue string `json:"minimumValue"`

	// Period The charges that occur on a schedule indicates the frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	Period *string `json:"period,omitempty"`
}

// EnergyPlanListResponse defines model for EnergyPlanListResponse.
type EnergyPlanListResponse struct {
	Data  EnergyPlanListResponseData `json:"data"`
	Links LinksPaginated             `json:"links"`
	Meta  MetaPaginated              `json:"meta"`
}

// EnergyPlanListResponseData defines model for EnergyPlanListResponse_data.
type EnergyPlanListResponseData struct {
	// Plans Array of plans
	Plans []EnergyPlan `json:"plans"`
}

// EnergyPlanResponse defines model for EnergyPlanResponse.
type EnergyPlanResponse struct {
	Data  EnergyPlanDetail        `json:"data"`
	Links Links                   `json:"links"`
	Meta  *map[string]interface{} `json:"meta,omitempty"`
}

// EnergyPlanAdditionalInformation Object that contains links to additional information on specific topics
type EnergyPlanAdditionalInformation struct {
	// BundleUri A link to detail on bundles that this plan can be a part of
	BundleUri *string `json:"bundleUri,omitempty"`

	// EligibilityUri A link to detail on eligibility criteria for the plan
	EligibilityUri *string `json:"eligibilityUri,omitempty"`

	// OverviewUri A link to a general overview of the plan
	OverviewUri *string `json:"overviewUri,omitempty"`

	// PricingUri A link to detail on pricing for the plan
	PricingUri *string `json:"pricingUri,omitempty"`

	// TermsUri A link to terms and conditions for the plan
	TermsUri *string `json:"termsUri,omitempty"`
}

// EnergyPlanGeography Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
type EnergyPlanGeography struct {
	// Distributors Array of distributors for the plan. Must have at least one entry
	Distributors []string `json:"distributors"`

	// ExcludedPostcodes Array of valid Australian post codes that are specifically excluded from the plan.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
	ExcludedPostcodes *[]string `json:"excludedPostcodes,omitempty"`

	// IncludedPostcodes Array of valid Australian post codes that are included from the plan.  If absent defaults to all non-excluded post codes.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
	IncludedPostcodes *[]string `json:"includedPostcodes,omitempty"`
}

// EnergyServicePoint defines model for EnergyServicePoint.
type EnergyServicePoint struct {
	ConsumerProfile *EnergyServicePointConsumerProfile `json:"consumerProfile,omitempty"`

	// IsGenerator This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
	IsGenerator *bool `json:"isGenerator,omitempty"`

	// JurisdictionCode Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
	JurisdictionCode EnergyServicePointJurisdictionCode `json:"jurisdictionCode"`

	// LastUpdateDateTime The date and time that the information for this service point was modified
	LastUpdateDateTime string `json:"lastUpdateDateTime"`

	// NationalMeteringId The independent ID of the service point, known in the industry as the NMI
	NationalMeteringId string `json:"nationalMeteringId"`

	// ServicePointClassification The classification of the service point as defined in MSATS procedures
	ServicePointClassification EnergyServicePointServicePointClassification `json:"servicePointClassification"`

	// ServicePointId Tokenised ID of the service point to be used for referring to the service point in the CDR API suite. To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`

	// ServicePointStatus Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
	ServicePointStatus EnergyServicePointServicePointStatus `json:"servicePointStatus"`

	// ValidFromDate The latest start date from which the constituent data sets of this service point became valid
	ValidFromDate string `json:"validFromDate"`
}

// EnergyServicePointJurisdictionCode Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
type EnergyServicePointJurisdictionCode string

// EnergyServicePointServicePointClassification The classification of the service point as defined in MSATS procedures
type EnergyServicePointServicePointClassification string

// EnergyServicePointServicePointStatus Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
type EnergyServicePointServicePointStatus string

// EnergyServicePointDetail defines model for EnergyServicePointDetail.
type EnergyServicePointDetail struct {
	ConsumerProfile        *EnergyServicePointConsumerProfile             `json:"consumerProfile,omitempty"`
	DistributionLossFactor EnergyServicePointDetailDistributionLossFactor `json:"distributionLossFactor"`

	// IsGenerator This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
	IsGenerator *bool `json:"isGenerator,omitempty"`

	// JurisdictionCode Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
	JurisdictionCode EnergyServicePointDetailJurisdictionCode `json:"jurisdictionCode"`

	// LastUpdateDateTime The date and time that the information for this service point was modified
	LastUpdateDateTime string                `json:"lastUpdateDateTime"`
	Location           CommonPhysicalAddress `json:"location"`

	// Meters The meters associated with the service point. This may be empty where there are no meters physically installed at the service point
	Meters *[]EnergyServicePointDetailMeters `json:"meters,omitempty"`

	// NationalMeteringId The independent ID of the service point, known in the industry as the NMI
	NationalMeteringId  string                                        `json:"nationalMeteringId"`
	RelatedParticipants []EnergyServicePointDetailRelatedParticipants `json:"relatedParticipants"`

	// ServicePointClassification The classification of the service point as defined in MSATS procedures
	ServicePointClassification EnergyServicePointDetailServicePointClassification `json:"servicePointClassification"`

	// ServicePointId The tokenised ID of the service point for use in the CDR APIs.  Created according to the CDR rules for ID permanence
	ServicePointId string `json:"servicePointId"`

	// ServicePointStatus Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
	ServicePointStatus EnergyServicePointDetailServicePointStatus `json:"servicePointStatus"`

	// ValidFromDate The latest start date from which the constituent data sets of this service point became valid
	ValidFromDate string `json:"validFromDate"`
}

// EnergyServicePointDetailJurisdictionCode Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
type EnergyServicePointDetailJurisdictionCode string

// EnergyServicePointDetailServicePointClassification The classification of the service point as defined in MSATS procedures
type EnergyServicePointDetailServicePointClassification string

// EnergyServicePointDetailServicePointStatus Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
type EnergyServicePointDetailServicePointStatus string

// EnergyServicePointDetailResponse defines model for EnergyServicePointDetailResponse.
type EnergyServicePointDetailResponse struct {
	Data  EnergyServicePointDetail `json:"data"`
	Links Links                    `json:"links"`
	Meta  *map[string]interface{}  `json:"meta,omitempty"`
}

// EnergyServicePointDetailDistributionLossFactor defines model for EnergyServicePointDetail_distributionLossFactor.
type EnergyServicePointDetailDistributionLossFactor struct {
	// Code A code used to identify data loss factor for the service point values.  Refer to AEMO distribution loss factor documents for each financial year to interpret
	Code string `json:"code"`

	// Description Description of the data loss factor code and value
	Description string `json:"description"`

	// LossValue The value associated with the loss factor code
	LossValue string `json:"lossValue"`
}

// EnergyServicePointDetailMeters defines model for EnergyServicePointDetail_meters.
type EnergyServicePointDetailMeters struct {
	// MeterId The meter ID uniquely identifies a meter for a given service point.  It is unique in the context of the service point.  It is not globally unique
	MeterId string `json:"meterId"`

	// Registers Usage data registers available from the meter. This may be empty where there are no meters physically installed at the service point
	Registers *[]EnergyServicePointDetailRegisters `json:"registers,omitempty"`

	// Specifications Technical characteristics of the meter
	Specifications EnergyServicePointDetailSpecifications `json:"specifications"`
}

// EnergyServicePointDetailRegisters defines model for EnergyServicePointDetail_registers.
type EnergyServicePointDetailRegisters struct {
	// AveragedDailyLoad The energy delivered through a connection point or metering point over an extended period normalised to a 'per day' basis (kWh). This value is calculated annually.
	AveragedDailyLoad *float32 `json:"averagedDailyLoad,omitempty"`

	// ConsumptionType Actual/Subtractive Indicator. Note the details of enumeration values below: <ul><li>**ACTUAL** implies volume of energy actually metered between two dates</li><li>**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates</li></ul>
	ConsumptionType *EnergyServicePointDetailRegistersConsumptionType `json:"consumptionType,omitempty"`

	// ControlledLoad Indicates whether the energy recorded by this register is created under a Controlled Load regime
	ControlledLoad *bool `json:"controlledLoad,omitempty"`

	// Multiplier Multiplier required to take a register value and turn it into a value representing billable energy
	Multiplier *float32 `json:"multiplier,omitempty"`

	// NetworkTariffCode The Network Tariff Code is a free text field containing a code supplied and published by the local network service provider
	NetworkTariffCode *string `json:"networkTariffCode,omitempty"`

	// RegisterConsumptionType Indicates the consumption type of register
	RegisterConsumptionType EnergyServicePointDetailRegistersRegisterConsumptionType `json:"registerConsumptionType"`

	// RegisterId Unique identifier of the register within this service point.  Is not globally unique
	RegisterId string `json:"registerId"`

	// RegisterSuffix Register suffix of the meter register where the meter reads are obtained
	RegisterSuffix *string `json:"registerSuffix,omitempty"`

	// TimeOfDay Code to identify the time validity of register contents
	TimeOfDay *EnergyServicePointDetailRegistersTimeOfDay `json:"timeOfDay,omitempty"`

	// UnitOfMeasure The unit of measure for data held in this register
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
}

// EnergyServicePointDetailRegistersConsumptionType Actual/Subtractive Indicator. Note the details of enumeration values below: <ul><li>**ACTUAL** implies volume of energy actually metered between two dates</li><li>**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates</li></ul>
type EnergyServicePointDetailRegistersConsumptionType string

// EnergyServicePointDetailRegistersRegisterConsumptionType Indicates the consumption type of register
type EnergyServicePointDetailRegistersRegisterConsumptionType string

// EnergyServicePointDetailRegistersTimeOfDay Code to identify the time validity of register contents
type EnergyServicePointDetailRegistersTimeOfDay string

// EnergyServicePointDetailRelatedParticipants defines model for EnergyServicePointDetail_relatedParticipants.
type EnergyServicePointDetailRelatedParticipants struct {
	// Party The name of the party/organisation related to this service point
	Party string `json:"party"`

	// Role The role performed by this participant in relation to the service point. Note the details of enumeration values below: <ul><li>**FRMP** - Financially Responsible Market Participant</li><li>**LNSP** - Local Network Service Provider or Embedded Network Manager for child connection points</li><li>**DRSP** - wholesale Demand Response and/or market ancillary Service Provider and note that where it is not relevant for a NMI it will not be included</li></ul>
	Role EnergyServicePointDetailRelatedParticipantsRole `json:"role"`
}

// EnergyServicePointDetailRelatedParticipantsRole The role performed by this participant in relation to the service point. Note the details of enumeration values below: <ul><li>**FRMP** - Financially Responsible Market Participant</li><li>**LNSP** - Local Network Service Provider or Embedded Network Manager for child connection points</li><li>**DRSP** - wholesale Demand Response and/or market ancillary Service Provider and note that where it is not relevant for a NMI it will not be included</li></ul>
type EnergyServicePointDetailRelatedParticipantsRole string

// EnergyServicePointDetailSpecifications Technical characteristics of the meter
type EnergyServicePointDetailSpecifications struct {
	// InstallationType The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: <ul><li>**BASIC** - Accumulation Meter – Type 6</li><li>**COMMS1** - Interval Meter with communications – Type 1</li><li>**COMMS2** - Interval Meter with communications – Type 2</li><li>**COMMS3** - Interval Meter with communications – Type 3</li><li>**COMMS4** - Interval Meter with communications – Type 4</li><li>**COMMS4C** - CT connected metering installation that meets the minimum services specifications</li><li>**COMMS4D** - Whole current metering installation that meets the minimum services specifications</li><li>**MRAM** - Small customer metering installation – Type 4A</li><li>**MRIM** - Manually Read Interval Meter – Type 5</li><li>**UMCP** - Unmetered Supply – Type 7</li><li>**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER</li><li>**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement</li></ul>
	InstallationType EnergyServicePointDetailSpecificationsInstallationType `json:"installationType"`

	// Manufacturer Free text field to identify the manufacturer of the installed meter
	Manufacturer *string `json:"manufacturer,omitempty"`

	// Model Free text field to identify the meter manufacturer’s designation for the meter model
	Model *string `json:"model,omitempty"`

	// NextScheduledReadDate This date is the next scheduled meter read date (NSRD) if a manual Meter Reading is required
	NextScheduledReadDate *string `json:"nextScheduledReadDate,omitempty"`

	// ReadType Code to denote the method and frequency of Meter Reading. The value is formatted as follows: <ul><li>First Character = Remote (R) or Manual (M)</li><li>Second Character = Mode: T = telephone W = wireless P = powerline I = infra-red G = galvanic V = visual </li><li>Third Character = Frequency of Scheduled Meter Readings: 1 = Twelve times per year 2 = Six times per year 3 = Four times per year D = Daily or weekly</li><li>Optional Fourth Character = to identify what interval length the meter is capable of reading. This includes five, 15 and 30 minute granularity as the following: A – 5 minute B – 15 minute C – 30 minute D – Cannot convert to 5 minute (i.e. due to metering installation de-energised) M - Manually Read Accumulation Meter</li></ul> For example, <ul><li>MV3 = Manual, Visual, Quarterly</li> <li>MV3M = Manual, Visual, Quarterly, Manually Read Accumulation Meter</li> <li>RWDC = Remote, Wireless, Daily, 30 minutes interval</li></ul>
	ReadType *string `json:"readType,omitempty"`

	// Status A code to denote the status of the meter. Note the details of enumeration values below: <ul><li>**CURRENT** -Applies when a meter is current and not disconnected</li><li>**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected</li></ul>
	Status EnergyServicePointDetailSpecificationsStatus `json:"status"`
}

// EnergyServicePointDetailSpecificationsInstallationType The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: <ul><li>**BASIC** - Accumulation Meter – Type 6</li><li>**COMMS1** - Interval Meter with communications – Type 1</li><li>**COMMS2** - Interval Meter with communications – Type 2</li><li>**COMMS3** - Interval Meter with communications – Type 3</li><li>**COMMS4** - Interval Meter with communications – Type 4</li><li>**COMMS4C** - CT connected metering installation that meets the minimum services specifications</li><li>**COMMS4D** - Whole current metering installation that meets the minimum services specifications</li><li>**MRAM** - Small customer metering installation – Type 4A</li><li>**MRIM** - Manually Read Interval Meter – Type 5</li><li>**UMCP** - Unmetered Supply – Type 7</li><li>**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER</li><li>**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement</li></ul>
type EnergyServicePointDetailSpecificationsInstallationType string

// EnergyServicePointDetailSpecificationsStatus A code to denote the status of the meter. Note the details of enumeration values below: <ul><li>**CURRENT** -Applies when a meter is current and not disconnected</li><li>**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected</li></ul>
type EnergyServicePointDetailSpecificationsStatus string

// EnergyServicePointListResponse defines model for EnergyServicePointListResponse.
type EnergyServicePointListResponse struct {
	Data  EnergyServicePointListResponseData `json:"data"`
	Links LinksPaginated                     `json:"links"`
	Meta  MetaPaginated                      `json:"meta"`
}

// EnergyServicePointListResponseData defines model for EnergyServicePointListResponse_data.
type EnergyServicePointListResponseData struct {
	ServicePoints []EnergyServicePoint `json:"servicePoints"`
}

// EnergyServicePointConsumerProfile defines model for EnergyServicePoint_consumerProfile.
type EnergyServicePointConsumerProfile struct {
	// Classification A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
	Classification *EnergyServicePointConsumerProfileClassification `json:"classification,omitempty"`

	// Threshold A code that defines the consumption threshold as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments. Note the details of enumeration values below: <ul><li>**LOW** - Consumption is less than the ‘lower consumption threshold’ as defined in the National Energy Retail Regulations</li><li>**MEDIUM** - Consumption is equal to or greater than the ‘lower consumption threshold’, but less than the ‘upper consumption threshold’, as defined in the National Energy Retail Regulations</li><li>**HIGH** - Consumption is equal to or greater than the ‘upper consumption threshold’ as defined in the National Energy Retail Regulations</li></ul>
	Threshold *EnergyServicePointConsumerProfileThreshold `json:"threshold,omitempty"`
}

// EnergyServicePointConsumerProfileClassification A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
type EnergyServicePointConsumerProfileClassification string

// EnergyServicePointConsumerProfileThreshold A code that defines the consumption threshold as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments. Note the details of enumeration values below: <ul><li>**LOW** - Consumption is less than the ‘lower consumption threshold’ as defined in the National Energy Retail Regulations</li><li>**MEDIUM** - Consumption is equal to or greater than the ‘lower consumption threshold’, but less than the ‘upper consumption threshold’, as defined in the National Energy Retail Regulations</li><li>**HIGH** - Consumption is equal to or greater than the ‘upper consumption threshold’ as defined in the National Energy Retail Regulations</li></ul>
type EnergyServicePointConsumerProfileThreshold string

// EnergyUsageListResponse defines model for EnergyUsageListResponse.
type EnergyUsageListResponse struct {
	Data  EnergyUsageListResponseData `json:"data"`
	Links LinksPaginated              `json:"links"`
	Meta  MetaPaginated               `json:"meta"`
}

// EnergyUsageListResponseData defines model for EnergyUsageListResponse_data.
type EnergyUsageListResponseData struct {
	// Reads Array of meter reads sorted by NMI in ascending order followed by readStartDate in descending order
	Reads []EnergyUsageRead `json:"reads"`
}

// EnergyUsageRead defines model for EnergyUsageRead.
type EnergyUsageRead struct {
	// BasicRead Mandatory if readUType is set to basicRead
	BasicRead *EnergyUsageReadBasicRead `json:"basicRead,omitempty"`

	// ControlledLoad Indicates whether the energy recorded by this register is created under a Controlled Load regime
	ControlledLoad *bool `json:"controlledLoad,omitempty"`

	// IntervalRead Mandatory if readUType is set to intervalRead
	IntervalRead *EnergyUsageReadIntervalRead `json:"intervalRead,omitempty"`

	// MeterId Meter id/serial number as it appears in customer’s bill. ID permanence rules do not apply.
	MeterId *string `json:"meterId,omitempty"`

	// ReadEndDate Date when the meter reads end in AEST.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate.
	ReadEndDate *string `json:"readEndDate,omitempty"`

	// ReadStartDate Date when the meter reads start in AEST and assumed to start from 12:00 am AEST.
	ReadStartDate string `json:"readStartDate"`

	// ReadUType Specify the type of the meter read data
	ReadUType EnergyUsageReadReadUType `json:"readUType"`

	// RegisterId Register ID of the meter register where the meter reads are obtained
	RegisterId *string `json:"registerId,omitempty"`

	// RegisterSuffix Register suffix of the meter register where the meter reads are obtained
	RegisterSuffix string `json:"registerSuffix"`

	// ServicePointId Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`

	// UnitOfMeasure Unit of measure of the meter reads. Refer to Appendix B of <a href='https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la=en&hash=03FCBA0D60E091DE00F2361AE76206EA'>MDFF Specification NEM12 NEM13 v2.1</a> for a list of possible values.
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
}

// EnergyUsageReadReadUType Specify the type of the meter read data
type EnergyUsageReadReadUType string

// EnergyUsageReadBasicRead Mandatory if readUType is set to basicRead
type EnergyUsageReadBasicRead struct {
	// Quality The quality of the read taken.  If absent then assumed to be ACTUAL
	Quality *EnergyUsageReadBasicReadQuality `json:"quality,omitempty"`

	// Value Meter read value.  If positive then it means consumption, if negative it means export
	Value float32 `json:"value"`
}

// EnergyUsageReadBasicReadQuality The quality of the read taken.  If absent then assumed to be ACTUAL
type EnergyUsageReadBasicReadQuality string

// EnergyUsageReadIntervalRead Mandatory if readUType is set to intervalRead
type EnergyUsageReadIntervalRead struct {
	// AggregateValue The aggregate sum of the interval read values. If positive then it means net consumption, if negative it means net export
	AggregateValue float32 `json:"aggregateValue"`

	// IntervalReads Array of Interval read values. If positive then it means consumption, if negative it means export. Required when interval-reads query parameter equals FULL or  MIN_30.<br>Each read value indicates the read for the interval specified by readIntervalLength beginning at midnight of readStartDate (for example 00:00 to 00:30 would be the first reading in a 30 minute Interval)
	IntervalReads *[]float32 `json:"intervalReads,omitempty"`

	// ReadIntervalLength Read interval length in minutes. Required when interval-reads query parameter equals FULL or MIN_30
	ReadIntervalLength *int `json:"readIntervalLength,omitempty"`

	// ReadQualities  Specifies quality of reads that are not ACTUAL.  For read indices that are not specified, quality is assumed to be ACTUAL. If not present, all quality of all reads are assumed to be actual. Required when interval-reads query parameter equals FULL or MIN_30
	ReadQualities *[]EnergyUsageReadIntervalReadReadQualities `json:"readQualities,omitempty"`
}

// EnergyUsageReadIntervalReadReadQualities defines model for EnergyUsageRead_intervalRead_readQualities.
type EnergyUsageReadIntervalReadReadQualities struct {
	// EndInterval End interval for read quality flag
	EndInterval int `json:"endInterval"`

	// Quality The quality of the read taken
	Quality EnergyUsageReadIntervalReadReadQualitiesQuality `json:"quality"`

	// StartInterval Start interval for read quality flag. First read begins at 1
	StartInterval int `json:"startInterval"`
}

// EnergyUsageReadIntervalReadReadQualitiesQuality The quality of the read taken
type EnergyUsageReadIntervalReadReadQualitiesQuality string

// Links defines model for Links.
type Links struct {
	// Self Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// LinksPaginated defines model for LinksPaginated.
type LinksPaginated struct {
	// First URI to the first page of this set. Mandatory if this response is not the first page
	First *string `json:"first,omitempty"`

	// Last URI to the last page of this set. Mandatory if this response is not the last page
	Last *string `json:"last,omitempty"`

	// Next URI to the next page of this set. Mandatory if this response is not the last page
	Next *string `json:"next,omitempty"`

	// Prev URI to the previous page of this set. Mandatory if this response is not the first page
	Prev *string `json:"prev,omitempty"`

	// Self Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// Meta defines model for Meta.
type Meta = map[string]interface{}

// MetaPaginated defines model for MetaPaginated.
type MetaPaginated struct {
	// TotalPages The total number of pages in the full set. See [pagination](#pagination).
	TotalPages int `json:"totalPages"`

	// TotalRecords The total number of records in the full set. See [pagination](#pagination).
	TotalRecords int `json:"totalRecords"`
}

// ResponseErrorListV2 defines model for ResponseErrorListV2.
type ResponseErrorListV2 struct {
	Errors []ResponseErrorListV2Errors `json:"errors"`
}

// ResponseErrorListV2Errors defines model for ResponseErrorListV2_errors.
type ResponseErrorListV2Errors struct {
	// Code The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Meta Additional data for customised error codes
	Meta *ResponseErrorListV2Meta `json:"meta,omitempty"`

	// Title A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
	Title string `json:"title"`
}

// ResponseErrorListV2Meta Additional data for customised error codes
type ResponseErrorListV2Meta struct {
	// Urn The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
	Urn *string `json:"urn,omitempty"`
}

// AccountIdList defines model for accountIdList.
type AccountIdList struct {
	Data struct {
		// AccountIds Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ServicePointIdList defines model for servicePointIdList.
type ServicePointIdList struct {
	Data struct {
		// ServicePointIds Array of specific servicePointIds to obtain data for
		ServicePointIds []string `json:"servicePointIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// OpenStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
	OpenStatus *ListAccountsParamsOpenStatus `form:"open-status,omitempty" json:"open-status,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListAccountsParamsOpenStatus defines parameters for ListAccounts.
type ListAccountsParamsOpenStatus string

// ListBalancesBulkParams defines parameters for ListBalancesBulk.
type ListBalancesBulkParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListBalancesForAccountsJSONBody defines parameters for ListBalancesForAccounts.
type ListBalancesForAccountsJSONBody struct {
	Data struct {
		// AccountIds Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListBalancesForAccountsParams defines parameters for ListBalancesForAccounts.
type ListBalancesForAccountsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListBillingBulkParams defines parameters for ListBillingBulk.
type ListBillingBulkParams struct {
	// NewestTime Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *string `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// OldestTime Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *string `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListBillingForAccountsJSONBody defines parameters for ListBillingForAccounts.
type ListBillingForAccountsJSONBody struct {
	Data struct {
		// AccountIds Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListBillingForAccountsParams defines parameters for ListBillingForAccounts.
type ListBillingForAccountsParams struct {
	// NewestTime Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *string `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// OldestTime Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *string `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListInvoicesBulkParams defines parameters for ListInvoicesBulk.
type ListInvoicesBulkParams struct {
	// NewestDate Constrain the request to records with issue date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// OldestDate Constrain the request to records with issue date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListInvoicesForAccountsJSONBody defines parameters for ListInvoicesForAccounts.
type ListInvoicesForAccountsJSONBody struct {
	Data struct {
		// AccountIds Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListInvoicesForAccountsParams defines parameters for ListInvoicesForAccounts.
type ListInvoicesForAccountsParams struct {
	// NewestDate Constrain the request to records with issue date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// OldestDate Constrain the request to records with issue date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetAccountParams defines parameters for GetAccount.
type GetAccountParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetBalanceForAccountParams defines parameters for GetBalanceForAccount.
type GetBalanceForAccountParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetBillingForAccountParams defines parameters for GetBillingForAccount.
type GetBillingForAccountParams struct {
	// NewestTime Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *string `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// OldestTime Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *string `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetConcessionsParams defines parameters for GetConcessions.
type GetConcessionsParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetInvoicesForAccountParams defines parameters for GetInvoicesForAccount.
type GetInvoicesForAccountParams struct {
	// NewestDate Constrain the request to records with issue date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// OldestDate Constrain the request to records with issue date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetPaymentScheduleParams defines parameters for GetPaymentSchedule.
type GetPaymentScheduleParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListServicePointsParams defines parameters for ListServicePoints.
type ListServicePointsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListDERBulkParams defines parameters for ListDERBulk.
type ListDERBulkParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListDERForServicePointsJSONBody defines parameters for ListDERForServicePoints.
type ListDERForServicePointsJSONBody struct {
	Data struct {
		// ServicePointIds Array of specific servicePointIds to obtain data for
		ServicePointIds []string `json:"servicePointIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListDERForServicePointsParams defines parameters for ListDERForServicePoints.
type ListDERForServicePointsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListUsageBulkParams defines parameters for ListUsageBulk.
type ListUsageBulkParams struct {
	// IntervalReads Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *ListUsageBulkParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// OldestDate Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// NewestDate Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListUsageBulkParamsIntervalReads defines parameters for ListUsageBulk.
type ListUsageBulkParamsIntervalReads string

// ListUsageForServicePointsJSONBody defines parameters for ListUsageForServicePoints.
type ListUsageForServicePointsJSONBody struct {
	Data struct {
		// ServicePointIds Array of specific servicePointIds to obtain data for
		ServicePointIds []string `json:"servicePointIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListUsageForServicePointsParams defines parameters for ListUsageForServicePoints.
type ListUsageForServicePointsParams struct {
	// OldestDate Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// NewestDate Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// IntervalReads Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *ListUsageForServicePointsParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListUsageForServicePointsParamsIntervalReads defines parameters for ListUsageForServicePoints.
type ListUsageForServicePointsParamsIntervalReads string

// GetServicePointParams defines parameters for GetServicePoint.
type GetServicePointParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetDERForServicePointParams defines parameters for GetDERForServicePoint.
type GetDERForServicePointParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetUsageForServicePointParams defines parameters for GetUsageForServicePoint.
type GetUsageForServicePointParams struct {
	// OldestDate Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// NewestDate Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// IntervalReads Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *GetUsageForServicePointParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetUsageForServicePointParamsIntervalReads defines parameters for GetUsageForServicePoint.
type GetUsageForServicePointParamsIntervalReads string

// ListPlansParams defines parameters for ListPlans.
type ListPlansParams struct {
	// Type Used to filter results on the type field.  Any one of the valid values for this field can be supplied plus 'ALL'.  If absent defaults to 'ALL'
	Type *ListPlansParamsType `form:"type,omitempty" json:"type,omitempty"`

	// FuelType Used to filter results on the fuelType field.  Any one of the valid values for this field can be supplied plus 'ALL'.  If absent defaults to 'ALL'
	FuelType *ListPlansParamsFuelType `form:"fuelType,omitempty" json:"fuelType,omitempty"`

	// Effective Allows for the filtering of plans based on whether the current time is within the period of time defined as effective by the effectiveFrom and effectiveTo fields. Valid values are ‘CURRENT’, ‘FUTURE’ and ‘ALL’. If absent defaults to 'CURRENT'
	Effective *ListPlansParamsEffective `form:"effective,omitempty" json:"effective,omitempty"`

	// UpdatedSince Only include plans that have been updated after the specified date and time.  If absent defaults to include all plans
	UpdatedSince *string `form:"updated-since,omitempty" json:"updated-since,omitempty"`

	// Brand Used to filter results on the brand field.  If absent defaults to include all plans
	Brand *string `form:"brand,omitempty" json:"brand,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// ListPlansParamsType defines parameters for ListPlans.
type ListPlansParamsType string

// ListPlansParamsFuelType defines parameters for ListPlans.
type ListPlansParamsFuelType string

// ListPlansParamsEffective defines parameters for ListPlans.
type ListPlansParamsEffective string

// GetPlanParams defines parameters for GetPlan.
type GetPlanParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// ListBalancesForAccountsJSONRequestBody defines body for ListBalancesForAccounts for application/json ContentType.
type ListBalancesForAccountsJSONRequestBody ListBalancesForAccountsJSONBody

// ListBillingForAccountsJSONRequestBody defines body for ListBillingForAccounts for application/json ContentType.
type ListBillingForAccountsJSONRequestBody ListBillingForAccountsJSONBody

// ListInvoicesForAccountsJSONRequestBody defines body for ListInvoicesForAccounts for application/json ContentType.
type ListInvoicesForAccountsJSONRequestBody ListInvoicesForAccountsJSONBody

// ListDERForServicePointsJSONRequestBody defines body for ListDERForServicePoints for application/json ContentType.
type ListDERForServicePointsJSONRequestBody ListDERForServicePointsJSONBody

// ListUsageForServicePointsJSONRequestBody defines body for ListUsageForServicePoints for application/json ContentType.
type ListUsageForServicePointsJSONRequestBody ListUsageForServicePointsJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBalancesBulk request
	ListBalancesBulk(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBalancesForAccounts request with any body
	ListBalancesForAccountsWithBody(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListBalancesForAccounts(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingBulk request
	ListBillingBulk(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingForAccounts request with any body
	ListBillingForAccountsWithBody(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListBillingForAccounts(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoicesBulk request
	ListInvoicesBulk(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoicesForAccounts request with any body
	ListInvoicesForAccountsWithBody(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListInvoicesForAccounts(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, accountId string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBalanceForAccount request
	GetBalanceForAccount(ctx context.Context, accountId string, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingForAccount request
	GetBillingForAccount(ctx context.Context, accountId string, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConcessions request
	GetConcessions(ctx context.Context, accountId string, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoicesForAccount request
	GetInvoicesForAccount(ctx context.Context, accountId string, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentSchedule request
	GetPaymentSchedule(ctx context.Context, accountId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServicePoints request
	ListServicePoints(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDERBulk request
	ListDERBulk(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDERForServicePoints request with any body
	ListDERForServicePointsWithBody(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListDERForServicePoints(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsageBulk request
	ListUsageBulk(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsageForServicePoints request with any body
	ListUsageForServicePointsWithBody(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListUsageForServicePoints(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicePoint request
	GetServicePoint(ctx context.Context, servicePointId string, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDERForServicePoint request
	GetDERForServicePoint(ctx context.Context, servicePointId string, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageForServicePoint request
	GetUsageForServicePoint(ctx context.Context, servicePointId string, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlans request
	ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlan request
	GetPlan(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesBulk(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesForAccountsWithBody(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesForAccounts(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingBulk(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingForAccountsWithBody(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingForAccounts(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesBulk(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesForAccountsWithBody(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesForAccounts(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccount(ctx context.Context, accountId string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBalanceForAccount(ctx context.Context, accountId string, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBalanceForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingForAccount(ctx context.Context, accountId string, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConcessions(ctx context.Context, accountId string, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConcessionsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoicesForAccount(ctx context.Context, accountId string, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoicesForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentSchedule(ctx context.Context, accountId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentScheduleRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServicePoints(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServicePointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERBulk(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERForServicePointsWithBody(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERForServicePointsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERForServicePoints(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERForServicePointsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageBulk(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageForServicePointsWithBody(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageForServicePointsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageForServicePoints(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageForServicePointsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicePoint(ctx context.Context, servicePointId string, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDERForServicePoint(ctx context.Context, servicePointId string, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDERForServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageForServicePoint(ctx context.Context, servicePointId string, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageForServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlan(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanRequest(c.Server, planId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OpenStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open-status", runtime.ParamLocationQuery, *params.OpenStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBalancesBulkRequest generates requests for ListBalancesBulk
func NewListBalancesBulkRequest(server string, params *ListBalancesBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBalancesForAccountsRequest calls the generic ListBalancesForAccounts builder with application/json body
func NewListBalancesForAccountsRequest(server string, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListBalancesForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListBalancesForAccountsRequestWithBody generates requests for ListBalancesForAccounts with any type of body
func NewListBalancesForAccountsRequestWithBody(server string, params *ListBalancesForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBillingBulkRequest generates requests for ListBillingBulk
func NewListBillingBulkRequest(server string, params *ListBillingBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/billing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBillingForAccountsRequest calls the generic ListBillingForAccounts builder with application/json body
func NewListBillingForAccountsRequest(server string, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListBillingForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListBillingForAccountsRequestWithBody generates requests for ListBillingForAccounts with any type of body
func NewListBillingForAccountsRequestWithBody(server string, params *ListBillingForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/billing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListInvoicesBulkRequest generates requests for ListInvoicesBulk
func NewListInvoicesBulkRequest(server string, params *ListInvoicesBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListInvoicesForAccountsRequest calls the generic ListInvoicesForAccounts builder with application/json body
func NewListInvoicesForAccountsRequest(server string, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListInvoicesForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListInvoicesForAccountsRequestWithBody generates requests for ListInvoicesForAccounts with any type of body
func NewListInvoicesForAccountsRequestWithBody(server string, params *ListInvoicesForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, accountId string, params *GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetBalanceForAccountRequest generates requests for GetBalanceForAccount
func NewGetBalanceForAccountRequest(server string, accountId string, params *GetBalanceForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/balance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetBillingForAccountRequest generates requests for GetBillingForAccount
func NewGetBillingForAccountRequest(server string, accountId string, params *GetBillingForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/billing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetConcessionsRequest generates requests for GetConcessions
func NewGetConcessionsRequest(server string, accountId string, params *GetConcessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/concessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetInvoicesForAccountRequest generates requests for GetInvoicesForAccount
func NewGetInvoicesForAccountRequest(server string, accountId string, params *GetInvoicesForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/invoices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetPaymentScheduleRequest generates requests for GetPaymentSchedule
func NewGetPaymentScheduleRequest(server string, accountId string, params *GetPaymentScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/payment-schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListServicePointsRequest generates requests for ListServicePoints
func NewListServicePointsRequest(server string, params *ListServicePointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListDERBulkRequest generates requests for ListDERBulk
func NewListDERBulkRequest(server string, params *ListDERBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/der")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListDERForServicePointsRequest calls the generic ListDERForServicePoints builder with application/json body
func NewListDERForServicePointsRequest(server string, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListDERForServicePointsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListDERForServicePointsRequestWithBody generates requests for ListDERForServicePoints with any type of body
func NewListDERForServicePointsRequestWithBody(server string, params *ListDERForServicePointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/der")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListUsageBulkRequest generates requests for ListUsageBulk
func NewListUsageBulkRequest(server string, params *ListUsageBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IntervalReads != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListUsageForServicePointsRequest calls the generic ListUsageForServicePoints builder with application/json body
func NewListUsageForServicePointsRequest(server string, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListUsageForServicePointsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListUsageForServicePointsRequestWithBody generates requests for ListUsageForServicePoints with any type of body
func NewListUsageForServicePointsRequestWithBody(server string, params *ListUsageForServicePointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IntervalReads != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetServicePointRequest generates requests for GetServicePoint
func NewGetServicePointRequest(server string, servicePointId string, params *GetServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetDERForServicePointRequest generates requests for GetDERForServicePoint
func NewGetDERForServicePointRequest(server string, servicePointId string, params *GetDERForServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s/der", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetUsageForServicePointRequest generates requests for GetUsageForServicePoint
func NewGetUsageForServicePointRequest(server string, servicePointId string, params *GetUsageForServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IntervalReads != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListPlansRequest generates requests for ListPlans
func NewListPlansRequest(server string, params *ListPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FuelType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fuelType", runtime.ParamLocationQuery, *params.FuelType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdatedSince != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated-since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Brand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brand", runtime.ParamLocationQuery, *params.Brand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	return req, nil
}

// NewGetPlanRequest generates requests for GetPlan
func NewGetPlanRequest(server string, planId string, params *GetPlanParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/plans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAccounts request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error)

	// ListBalancesBulk request
	ListBalancesBulkWithResponse(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*ListBalancesBulkResponse, error)

	// ListBalancesForAccounts request with any body
	ListBalancesForAccountsWithBodyWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error)

	ListBalancesForAccountsWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error)

	// ListBillingBulk request
	ListBillingBulkWithResponse(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*ListBillingBulkResponse, error)

	// ListBillingForAccounts request with any body
	ListBillingForAccountsWithBodyWithResponse(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error)

	ListBillingForAccountsWithResponse(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error)

	// ListInvoicesBulk request
	ListInvoicesBulkWithResponse(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*ListInvoicesBulkResponse, error)

	// ListInvoicesForAccounts request with any body
	ListInvoicesForAccountsWithBodyWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error)

	ListInvoicesForAccountsWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error)

	// GetAccount request
	GetAccountWithResponse(ctx context.Context, accountId string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error)

	// GetBalanceForAccount request
	GetBalanceForAccountWithResponse(ctx context.Context, accountId string, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*GetBalanceForAccountResponse, error)

	// GetBillingForAccount request
	GetBillingForAccountWithResponse(ctx context.Context, accountId string, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*GetBillingForAccountResponse, error)

	// GetConcessions request
	GetConcessionsWithResponse(ctx context.Context, accountId string, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*GetConcessionsResponse, error)

	// GetInvoicesForAccount request
	GetInvoicesForAccountWithResponse(ctx context.Context, accountId string, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*GetInvoicesForAccountResponse, error)

	// GetPaymentSchedule request
	GetPaymentScheduleWithResponse(ctx context.Context, accountId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*GetPaymentScheduleResponse, error)

	// ListServicePoints request
	ListServicePointsWithResponse(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*ListServicePointsResponse, error)

	// ListDERBulk request
	ListDERBulkWithResponse(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*ListDERBulkResponse, error)

	// ListDERForServicePoints request with any body
	ListDERForServicePointsWithBodyWithResponse(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error)

	ListDERForServicePointsWithResponse(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error)

	// ListUsageBulk request
	ListUsageBulkWithResponse(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*ListUsageBulkResponse, error)

	// ListUsageForServicePoints request with any body
	ListUsageForServicePointsWithBodyWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error)

	ListUsageForServicePointsWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error)

	// GetServicePoint request
	GetServicePointWithResponse(ctx context.Context, servicePointId string, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*GetServicePointResponse, error)

	// GetDERForServicePoint request
	GetDERForServicePointWithResponse(ctx context.Context, servicePointId string, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*GetDERForServicePointResponse, error)

	// GetUsageForServicePoint request
	GetUsageForServicePointWithResponse(ctx context.Context, servicePointId string, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*GetUsageForServicePointResponse, error)

	// ListPlans request
	ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error)

	// GetPlan request
	GetPlanWithResponse(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*GetPlanResponse, error)
}

type ListAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyAccountListResponseV2
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBalancesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBalancesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBalancesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBalancesForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBalancesForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBalancesForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBillingBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBillingForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListInvoicesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListInvoicesForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyAccountDetailResponseV2
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBalanceForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetBalanceForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBalanceForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetBillingForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConcessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyConcessionsResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetConcessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConcessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetInvoicesForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPaymentScheduleResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetPaymentScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyServicePointListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDERBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListDERBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDERBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDERForServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListDERForServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDERForServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsageBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListUsageBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsageForServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListUsageForServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageForServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyServicePointDetailResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDERForServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerDetailResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDERForServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDERForServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageForServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetUsageForServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageForServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPlanListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPlanResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAccountsWithResponse request returning *ListAccountsResponse
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error) {
	rsp, err := c.ListAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResponse(rsp)
}

// ListBalancesBulkWithResponse request returning *ListBalancesBulkResponse
func (c *ClientWithResponses) ListBalancesBulkWithResponse(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*ListBalancesBulkResponse, error) {
	rsp, err := c.ListBalancesBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesBulkResponse(rsp)
}

// ListBalancesForAccountsWithBodyWithResponse request with arbitrary body returning *ListBalancesForAccountsResponse
func (c *ClientWithResponses) ListBalancesForAccountsWithBodyWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error) {
	rsp, err := c.ListBalancesForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListBalancesForAccountsWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error) {
	rsp, err := c.ListBalancesForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesForAccountsResponse(rsp)
}

// ListBillingBulkWithResponse request returning *ListBillingBulkResponse
func (c *ClientWithResponses) ListBillingBulkWithResponse(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*ListBillingBulkResponse, error) {
	rsp, err := c.ListBillingBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingBulkResponse(rsp)
}

// ListBillingForAccountsWithBodyWithResponse request with arbitrary body returning *ListBillingForAccountsResponse
func (c *ClientWithResponses) ListBillingForAccountsWithBodyWithResponse(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error) {
	rsp, err := c.ListBillingForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListBillingForAccountsWithResponse(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error) {
	rsp, err := c.ListBillingForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingForAccountsResponse(rsp)
}

// ListInvoicesBulkWithResponse request returning *ListInvoicesBulkResponse
func (c *ClientWithResponses) ListInvoicesBulkWithResponse(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*ListInvoicesBulkResponse, error) {
	rsp, err := c.ListInvoicesBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesBulkResponse(rsp)
}

// ListInvoicesForAccountsWithBodyWithResponse request with arbitrary body returning *ListInvoicesForAccountsResponse
func (c *ClientWithResponses) ListInvoicesForAccountsWithBodyWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error) {
	rsp, err := c.ListInvoicesForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListInvoicesForAccountsWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error) {
	rsp, err := c.ListInvoicesForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesForAccountsResponse(rsp)
}

// GetAccountWithResponse request returning *GetAccountResponse
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, accountId string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error) {
	rsp, err := c.GetAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResponse(rsp)
}

// GetBalanceForAccountWithResponse request returning *GetBalanceForAccountResponse
func (c *ClientWithResponses) GetBalanceForAccountWithResponse(ctx context.Context, accountId string, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*GetBalanceForAccountResponse, error) {
	rsp, err := c.GetBalanceForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBalanceForAccountResponse(rsp)
}

// GetBillingForAccountWithResponse request returning *GetBillingForAccountResponse
func (c *ClientWithResponses) GetBillingForAccountWithResponse(ctx context.Context, accountId string, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*GetBillingForAccountResponse, error) {
	rsp, err := c.GetBillingForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingForAccountResponse(rsp)
}

// GetConcessionsWithResponse request returning *GetConcessionsResponse
func (c *ClientWithResponses) GetConcessionsWithResponse(ctx context.Context, accountId string, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*GetConcessionsResponse, error) {
	rsp, err := c.GetConcessions(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConcessionsResponse(rsp)
}

// GetInvoicesForAccountWithResponse request returning *GetInvoicesForAccountResponse
func (c *ClientWithResponses) GetInvoicesForAccountWithResponse(ctx context.Context, accountId string, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*GetInvoicesForAccountResponse, error) {
	rsp, err := c.GetInvoicesForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesForAccountResponse(rsp)
}

// GetPaymentScheduleWithResponse request returning *GetPaymentScheduleResponse
func (c *ClientWithResponses) GetPaymentScheduleWithResponse(ctx context.Context, accountId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*GetPaymentScheduleResponse, error) {
	rsp, err := c.GetPaymentSchedule(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentScheduleResponse(rsp)
}

// ListServicePointsWithResponse request returning *ListServicePointsResponse
func (c *ClientWithResponses) ListServicePointsWithResponse(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*ListServicePointsResponse, error) {
	rsp, err := c.ListServicePoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServicePointsResponse(rsp)
}

// ListDERBulkWithResponse request returning *ListDERBulkResponse
func (c *ClientWithResponses) ListDERBulkWithResponse(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*ListDERBulkResponse, error) {
	rsp, err := c.ListDERBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERBulkResponse(rsp)
}

// ListDERForServicePointsWithBodyWithResponse request with arbitrary body returning *ListDERForServicePointsResponse
func (c *ClientWithResponses) ListDERForServicePointsWithBodyWithResponse(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error) {
	rsp, err := c.ListDERForServicePointsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERForServicePointsResponse(rsp)
}

func (c *ClientWithResponses) ListDERForServicePointsWithResponse(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error) {
	rsp, err := c.ListDERForServicePoints(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERForServicePointsResponse(rsp)
}

// ListUsageBulkWithResponse request returning *ListUsageBulkResponse
func (c *ClientWithResponses) ListUsageBulkWithResponse(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*ListUsageBulkResponse, error) {
	rsp, err := c.ListUsageBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageBulkResponse(rsp)
}

// ListUsageForServicePointsWithBodyWithResponse request with arbitrary body returning *ListUsageForServicePointsResponse
func (c *ClientWithResponses) ListUsageForServicePointsWithBodyWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error) {
	rsp, err := c.ListUsageForServicePointsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageForServicePointsResponse(rsp)
}

func (c *ClientWithResponses) ListUsageForServicePointsWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error) {
	rsp, err := c.ListUsageForServicePoints(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageForServicePointsResponse(rsp)
}

// GetServicePointWithResponse request returning *GetServicePointResponse
func (c *ClientWithResponses) GetServicePointWithResponse(ctx context.Context, servicePointId string, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*GetServicePointResponse, error) {
	rsp, err := c.GetServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicePointResponse(rsp)
}

// GetDERForServicePointWithResponse request returning *GetDERForServicePointResponse
func (c *ClientWithResponses) GetDERForServicePointWithResponse(ctx context.Context, servicePointId string, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*GetDERForServicePointResponse, error) {
	rsp, err := c.GetDERForServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDERForServicePointResponse(rsp)
}

// GetUsageForServicePointWithResponse request returning *GetUsageForServicePointResponse
func (c *ClientWithResponses) GetUsageForServicePointWithResponse(ctx context.Context, servicePointId string, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*GetUsageForServicePointResponse, error) {
	rsp, err := c.GetUsageForServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageForServicePointResponse(rsp)
}

// ListPlansWithResponse request returning *ListPlansResponse
func (c *ClientWithResponses) ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error) {
	rsp, err := c.ListPlans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlansResponse(rsp)
}

// GetPlanWithResponse request returning *GetPlanResponse
func (c *ClientWithResponses) GetPlanWithResponse(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*GetPlanResponse, error) {
	rsp, err := c.GetPlan(ctx, planId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanResponse(rsp)
}

// ParseListAccountsResponse parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResponse(rsp *http.Response) (*ListAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyAccountListResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBalancesBulkResponse parses an HTTP response from a ListBalancesBulkWithResponse call
func ParseListBalancesBulkResponse(rsp *http.Response) (*ListBalancesBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBalancesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBalancesForAccountsResponse parses an HTTP response from a ListBalancesForAccountsWithResponse call
func ParseListBalancesForAccountsResponse(rsp *http.Response) (*ListBalancesForAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBalancesForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBillingBulkResponse parses an HTTP response from a ListBillingBulkWithResponse call
func ParseListBillingBulkResponse(rsp *http.Response) (*ListBillingBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBillingForAccountsResponse parses an HTTP response from a ListBillingForAccountsWithResponse call
func ParseListBillingForAccountsResponse(rsp *http.Response) (*ListBillingForAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListInvoicesBulkResponse parses an HTTP response from a ListInvoicesBulkWithResponse call
func ParseListInvoicesBulkResponse(rsp *http.Response) (*ListInvoicesBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListInvoicesForAccountsResponse parses an HTTP response from a ListInvoicesForAccountsWithResponse call
func ParseListInvoicesForAccountsResponse(rsp *http.Response) (*ListInvoicesForAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAccountResponse parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResponse(rsp *http.Response) (*GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyAccountDetailResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetBalanceForAccountResponse parses an HTTP response from a GetBalanceForAccountWithResponse call
func ParseGetBalanceForAccountResponse(rsp *http.Response) (*GetBalanceForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBalanceForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetBillingForAccountResponse parses an HTTP response from a GetBillingForAccountWithResponse call
func ParseGetBillingForAccountResponse(rsp *http.Response) (*GetBillingForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetConcessionsResponse parses an HTTP response from a GetConcessionsWithResponse call
func ParseGetConcessionsResponse(rsp *http.Response) (*GetConcessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConcessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyConcessionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetInvoicesForAccountResponse parses an HTTP response from a GetInvoicesForAccountWithResponse call
func ParseGetInvoicesForAccountResponse(rsp *http.Response) (*GetInvoicesForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPaymentScheduleResponse parses an HTTP response from a GetPaymentScheduleWithResponse call
func ParseGetPaymentScheduleResponse(rsp *http.Response) (*GetPaymentScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPaymentScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListServicePointsResponse parses an HTTP response from a ListServicePointsWithResponse call
func ParseListServicePointsResponse(rsp *http.Response) (*ListServicePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyServicePointListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListDERBulkResponse parses an HTTP response from a ListDERBulkWithResponse call
func ParseListDERBulkResponse(rsp *http.Response) (*ListDERBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDERBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListDERForServicePointsResponse parses an HTTP response from a ListDERForServicePointsWithResponse call
func ParseListDERForServicePointsResponse(rsp *http.Response) (*ListDERForServicePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDERForServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListUsageBulkResponse parses an HTTP response from a ListUsageBulkWithResponse call
func ParseListUsageBulkResponse(rsp *http.Response) (*ListUsageBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsageBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListUsageForServicePointsResponse parses an HTTP response from a ListUsageForServicePointsWithResponse call
func ParseListUsageForServicePointsResponse(rsp *http.Response) (*ListUsageForServicePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsageForServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetServicePointResponse parses an HTTP response from a GetServicePointWithResponse call
func ParseGetServicePointResponse(rsp *http.Response) (*GetServicePointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyServicePointDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDERForServicePointResponse parses an HTTP response from a GetDERForServicePointWithResponse call
func ParseGetDERForServicePointResponse(rsp *http.Response) (*GetDERForServicePointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDERForServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetUsageForServicePointResponse parses an HTTP response from a GetUsageForServicePointWithResponse call
func ParseGetUsageForServicePointResponse(rsp *http.Response) (*GetUsageForServicePointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageForServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListPlansResponse parses an HTTP response from a ListPlansWithResponse call
func ParseListPlansResponse(rsp *http.Response) (*ListPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPlanListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPlanResponse parses an HTTP response from a GetPlanWithResponse call
func ParseGetPlanResponse(rsp *http.Response) (*GetPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
